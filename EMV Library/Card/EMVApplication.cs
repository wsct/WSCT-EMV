using System;
using System.Collections.Generic;
using System.Globalization;
using WSCT.Core;
using WSCT.EMV.Commands;
using WSCT.EMV.Exceptions;
using WSCT.EMV.Objects;
using WSCT.EMV.Security;
using WSCT.Helpers;
using WSCT.Helpers.BasicEncodingRules;
using WSCT.Helpers.Events;
using WSCT.ISO7816;
using WSCT.ISO7816.Commands;

namespace WSCT.EMV.Card
{
    /// <summary>
    /// An <c>EMVApplication</c> instance represents an EMV application.
    /// Allows selection and use of the application.
    /// </summary>
    /// <example>
    ///     <code>
    /// ICardChannel cardChannel;
    /// // ... acquire here a valid cardChannel instance ...
    /// EMVApplication emvApp = new EMVApplication(cardChannel);
    /// emvApp.aid = "A0 00 00 00 03 10 10";
    /// emvApp.select();
    /// emvApp.getProcessingOptions();
    ///     </code>
    /// </example>
    public class EmvApplication : EmvDefinitionFile
    {
        #region >> Fields

        protected ApplicationFileLocator _afl;
        protected ApplicationInterchangeProfile _aip;
        protected ApplicationCryptogram _applicationCryptogram1;
        protected ApplicationTransactionCounter _atcFromAC1;
        protected CombinedDataAuthentication _cda;
        protected DataObjectList _cdol1;
        protected DataObjectList _cdol2;

        protected PublicKey _certificationAuthorityPublicKey;
        protected CertificationAuthorityRepository _certificationAuthorityRepository;
        protected CryptogramInformationData _cid1;
        protected CardholderVerificationMethodList _cvmList;
        protected DynamicDataAuthentication _dda;
        protected DataObjectList _ddol;
        protected byte[] _iccChallenge;
        protected PublicKey _iccPublicKey;
        protected IccPublicKeyCertificate _iccPublicKeyCertificate;
        protected PublicKey _issuerPublicKey;
        protected IssuerPublicKeyCertificate _issuerPublicKeyCertificate;
        protected LogEntry _logEntry;
        protected DataObjectList _logFormat;
        protected List<List<TlvData>> _logRecords;
        protected CryptogramType _requestedAC1Type;
        protected CryptogramType _requestedAC2Type;

        protected StaticDataAuthentication _sda;
        protected TlvData _tlvATC;
        protected TlvData _tlvCryptographicChecksum;
        protected TlvData _tlvFromPSE;
        protected TlvData _tlvGenerateAC1Response;
        protected TlvData _tlvGenerateAC1UnpredictableNumber;
        protected TlvData _tlvGenerateAC2Response;
        protected TlvData _tlvInternalAuthenticateUnpredictableNumber;
        protected TlvData _tlvLastOnlineATCRegister;
        protected TlvData _tlvLogFormat;
        protected List<TlvData> _tlvOfflineRecords;
        protected TlvData _tlvPINTryCounter;
        protected TlvData _tlvProcessingOptions;
        protected List<TlvData> _tlvRecords;
        protected TlvData _tlvSignedDynamicApplicationResponse;
        protected List<TlvData> _tlvTerminalData;

        protected TerminalVerificationResult _tvr;

        protected UInt16 _verifyPinStatusWord;

        #endregion

        #region >> Properties

        /// <summary>
        /// Accessor to the certification authority public key repository.
        /// </summary>
        public CertificationAuthorityRepository CertificationAuthorityRepository
        {
            get
            {
                if (_certificationAuthorityRepository == null)
                {
                    _certificationAuthorityRepository = new CertificationAuthorityRepository();
                }
                return _certificationAuthorityRepository;
            }
            set { _certificationAuthorityRepository = value; }
        }

        /// <summary>
        /// Accessor to public terminal data in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvTerminalData
        {
            get
            {
                if (_tlvTerminalData == null)
                {
                    _tlvTerminalData = new List<TlvData>();
                }
                return _tlvTerminalData;
            }
            set { _tlvTerminalData = value; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TlvData"/>.
        /// </summary>
        public TlvData TlvDataTerminalData
        {
            get { return new TlvData(0x00, 0x00, null) { SubFields = _tlvTerminalData }; }
        }

        /// <summary>
        /// Accessor to the Cryptographic Checksum generated by the application.
        /// </summary>
        public TlvData TlvCryptographicChecksum
        {
            get { return _tlvCryptographicChecksum; }
        }

        /// <summary>
        /// Accessor to the TVR of the application.
        /// </summary>
        public TerminalVerificationResult Tvr
        {
            get
            {
                if (_tvr == null)
                {
                    _tvr = new TerminalVerificationResult(new TlvData("95 05 00 00 00 00 80"));
                }

                return _tvr;
            }
        }

        /// <summary>
        /// Accessor to the AFL of the application.
        /// </summary>
        public ApplicationFileLocator Afl
        {
            get
            {
                if (_afl == null && _tlvProcessingOptions != null)
                {
                    if (TlvProcessingOptions.Tag == 0x80)
                    {
                        // Format 1
                        var rawAfl = new byte[_tlvProcessingOptions.Value.Length - 2];
                        Array.Copy(_tlvProcessingOptions.Value, 2, rawAfl, 0, rawAfl.Length);
                        _afl = new ApplicationFileLocator(rawAfl);
                    }
                    else if (_tlvProcessingOptions.Tag == 0x77)
                    {
                        _afl = new ApplicationFileLocator(_tlvProcessingOptions.GetTag(0x94).Value);
                    }
                }
                return _afl;
            }
        }

        /// <summary>
        /// Accessor to the AIP of the application.
        /// </summary>
        public ApplicationInterchangeProfile Aip
        {
            get
            {
                if (_aip == null && _tlvProcessingOptions != null)
                {
                    if (TlvProcessingOptions.Tag == 0x80)
                    {
                        // Format 1
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.Value[0], _tlvProcessingOptions.Value[1]);
                    }
                    else if (_tlvProcessingOptions.Tag == 0x77)
                    {
                        // Format 2
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.GetTag(0x82).Value);
                    }
                }
                return _aip;
            }
        }

        /// <summary>
        /// Accessor to the CVM list of the application.
        /// </summary>
        public CardholderVerificationMethodList CvmList
        {
            get
            {
                if (_cvmList == null && _tlvRecords != null)
                {
                    foreach (var record in TlvRecords)
                    {
                        if (record.HasTag(0x8E))
                        {
                            _cvmList = new CardholderVerificationMethodList(record.GetTag(0x8E));
                            break;
                        }
                    }
                }
                return _cvmList;
            }
        }

        /// <summary>
        /// Accessor to the Log Entry.
        /// </summary>
        public LogEntry LogEntry
        {
            get
            {
                if (_logEntry == null && TlvFci != null && TlvFci.HasTag(0x9F4D))
                {
                    _logEntry = new LogEntry(TlvFci.GetTag(0x9F4D));
                }
                return _logEntry;
            }
        }

        /// <summary>
        /// Accessor to the Log Format.
        /// </summary>
        public DataObjectList LogFormat
        {
            get
            {
                if (_logFormat == null && TlvLogFormat != null)
                {
                    _logFormat = new DataObjectList(_tlvLogFormat.Value);
                }
                return _logFormat;
            }
        }

        /// <summary>
        /// Accessor to the records read from log file.
        /// </summary>
        public List<List<TlvData>> LogRecords
        {
            get { return _logRecords; }
        }

        /// <summary>
        /// Accessor to the informations coming from PSE in <see cref="TlvData"/> format (if available).
        /// </summary>
        public TlvData TlvFromPSE
        {
            get { return _tlvFromPSE; }
        }

        /// <summary>
        /// Accessor to the processing options in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvProcessingOptions
        {
            get { return _tlvProcessingOptions; }
        }

        /// <summary>
        /// Accessor to the data read in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvRecords
        {
            get { return _tlvRecords; }
            set { _tlvRecords = value; }
        }

        /// <summary>
        /// Accessor to the offline signed data in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvOfflineRecords
        {
            get { return _tlvOfflineRecords; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TlvData"/>.
        /// </summary>
        public TlvData TlvDataRecords
        {
            get { return _tlvRecords.ToTlvData(0x20); }
        }

        /// <summary>
        /// Accessor to ATC (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvATC
        {
            get { return _tlvATC; }
        }

        /// <summary>
        /// Accessor to Last Online ATC Register (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvLastOnlineATCRegister
        {
            get { return _tlvLastOnlineATCRegister; }
            set { _tlvLastOnlineATCRegister = value; }
        }

        /// <summary>
        /// Accessor to PIN Try Counter (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvPINTryCounter
        {
            get { return _tlvPINTryCounter; }
            set { _tlvPINTryCounter = value; }
        }

        /// <summary>
        /// Accessor to Log Format (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvLogFormat
        {
            get { return _tlvLogFormat; }
            set { _tlvLogFormat = value; }
        }

        /// <summary>
        /// Accessor to DDOL.
        /// </summary>
        public DataObjectList Ddol
        {
            get
            {
                if (_ddol == null && TlvDataRecords.HasTag(0x9F49))
                {
                    _ddol = new DataObjectList(TlvDataRecords.GetTag(0x9F49).Value);
                }
                return _ddol;
            }
        }

        /// <summary>
        /// Accessor to CDOL1.
        /// </summary>
        public DataObjectList Cdol1
        {
            get
            {
                if (_cdol1 == null && TlvDataRecords.HasTag(0x8C))
                {
                    _cdol1 = new DataObjectList(TlvDataRecords.GetTag(0x8C).Value);
                }
                return _cdol1;
            }
        }

        /// <summary>
        /// Accessor to CDOL2.
        /// </summary>
        public DataObjectList Cdol2
        {
            get
            {
                if (_cdol2 == null && TlvDataRecords.HasTag(0x8D))
                {
                    _cdol2 = new DataObjectList(TlvDataRecords.GetTag(0x8D).Value);
                }
                return _cdol2;
            }
        }

        /// <summary>
        /// Accessor to the Certification Authority Public Key.
        /// </summary>
        public PublicKey CertificationAuthorityPublicKey
        {
            get
            {
                if (_certificationAuthorityPublicKey == null && TlvDataRecords.HasTag(0x8F))
                {
                    var caPublicKeyIndex = new CertificationAuthorityPublicKeyIndex(TlvDataRecords.GetTag(0x8F));
                    var aidObject = new ApplicationIdentifier(Aid);
                    try
                    {
                        _certificationAuthorityPublicKey = CertificationAuthorityRepository.Get(aidObject.StrRid, caPublicKeyIndex.Tlv.Value.ToHexa());
                    }
                    catch (EMVCertificationAuthorityNotFoundException)
                    {
                        // TODO: something when CA is not found
                    }
                }
                return _certificationAuthorityPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key Certificate.
        /// </summary>
        public IssuerPublicKeyCertificate IssuerPublicKeyCertificate
        {
            get
            {
                if (_issuerPublicKeyCertificate == null && CertificationAuthorityPublicKey != null && TlvDataRecords.HasTag(0x90))
                {
                    _issuerPublicKeyCertificate = new IssuerPublicKeyCertificate();
                    _issuerPublicKeyCertificate.RecoverFromSignature(TlvDataRecords.GetTag(0x90).Value, CertificationAuthorityPublicKey);
                }
                return _issuerPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key (recovered from Issuer Public Key Certificate).
        /// </summary>
        public PublicKey IssuerPublicKey
        {
            get
            {
                if (_issuerPublicKey == null && IssuerPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    var modulus = IssuerPublicKeyCertificate.PublicKeyorLeftmostDigitsofthePublicKey.ToHexa();
                    if (TlvDataRecords.HasTag(0x92))
                    {
                        modulus += TlvDataRecords.GetTag(0x92).Value.ToHexa();
                    }
                    // Exponent from the ICC records
                    var exponent = TlvDataRecords.GetTag(0x9F32).Value.ToHexa();
                    // Compute the public key
                    _issuerPublicKey = new PublicKey(modulus, exponent);
                }
                return _issuerPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key Certificate.
        /// </summary>
        public IccPublicKeyCertificate IccPublicKeyCertificate
        {
            get
            {
                if (_iccPublicKeyCertificate == null && IssuerPublicKey != null && TlvDataRecords.HasTag(0x9F46))
                {
                    _iccPublicKeyCertificate = new IccPublicKeyCertificate();
                    _iccPublicKeyCertificate.RecoverFromSignature(TlvDataRecords.GetTag(0x9F46).Value, IssuerPublicKey);
                }
                return _iccPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key (recovered from ICC Public Key Certificate).
        /// </summary>
        public PublicKey IccPublicKey
        {
            get
            {
                if (_iccPublicKey == null && IccPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    var modulus = IccPublicKeyCertificate.PublicKeyorLeftmostDigitsofthePublicKey.ToHexa();
                    if (TlvDataRecords.HasTag(0x9F48))
                    {
                        modulus += TlvDataRecords.GetTag(0x9F48).Value.ToHexa();
                    }
                    // Exponent from the ICC records
                    var exponent = TlvDataRecords.GetTag(0x9F47).Value.ToHexa();
                    // Compute the public key
                    _iccPublicKey = new PublicKey(modulus, exponent);
                }
                return _iccPublicKey;
            }
        }

        /// <summary>
        /// Accessor to SDA data.
        /// </summary>
        public StaticDataAuthentication Sda
        {
            get
            {
                if (_sda == null && TlvDataRecords.HasTag(0x93) && IssuerPublicKeyCertificate != null)
                {
                    _sda = new StaticDataAuthentication();
                    _sda.RecoverFromSignature(TlvDataRecords.GetTag(0x93).Value, IssuerPublicKey);
                }
                return _sda;
            }
        }

        /// <summary>
        /// Accessor to DDA data.
        /// </summary>
        public virtual DynamicDataAuthentication Dda
        {
            get
            {
                if (_dda == null && TlvSignedDynamicApplicationResponse != null && IccPublicKeyCertificate != null)
                {
                    if (TlvDataRecords.HasTag(0x8F))
                    {
                        byte[] signature = null;
                        if (TlvSignedDynamicApplicationResponse.Tag == 0x80)
                        {
                            // Format 1
                            signature = TlvSignedDynamicApplicationResponse.Value;
                        }
                        else if (TlvSignedDynamicApplicationResponse.Tag == 0x77)
                        {
                            // Format 2
                            signature = TlvSignedDynamicApplicationResponse.GetTag(0x9F4B).Value;
                        }
                        _dda = new DynamicDataAuthentication();
                        _dda.RecoverFromSignature(signature, IccPublicKey);
                    }
                }
                return _dda;
            }
        }

        /// <summary>
        /// Accessor to CDA data.
        /// </summary>
        public CombinedDataAuthentication Cda
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for INTERNAL AUTHENTICATE (DDA).
        /// </summary>
        public TlvData TlvInternalAuthenticateUnpredictableNumber
        {
            get { return _tlvInternalAuthenticateUnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the Signed Dynamic Application rAPDU obtained by INTERNAL AUTHENTICATE.
        /// </summary>
        /// <remarks>
        /// From EMV book 3:
        /// <para>Format 1: The data object returned in the rAPDU message is a primitive data object with tag equal to '80'.
        /// The value field consists of the value field of the Signed Dynamic Application Data as specified in Book 2</para>
        /// <para>Format 2: The data object returned in the rAPDU message is a constructed data object with tag equal to '77'.
        /// The value field may contain several BER-TLV coded objects, but shall always include the Signed Dynamic Application Data as specified in Book 2.</para>
        /// </remarks>
        public TlvData TlvSignedDynamicApplicationResponse
        {
            get { return _tlvSignedDynamicApplicationResponse; }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for GENERATE AC 1.
        /// </summary>
        public TlvData TlvGenerateAC1UnpredictableNumber
        {
            get { return _tlvGenerateAC1UnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC1.
        /// </summary>
        public TlvData TlvGenerateAC1Response
        {
            get { return _tlvGenerateAC1Response; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC2.
        /// </summary>
        public TlvData TlvGenerateAC2Response
        {
            get { return _tlvGenerateAC2Response; }
        }

        /// <summary>
        /// Accessor to last GET CHALLENGE rAPDU.
        /// </summary>
        public byte[] IccChallenge
        {
            get { return _iccChallenge; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by VERIFY PIN.
        /// </summary>
        public UInt16 VerifyPinStatusWord
        {
            get { return _verifyPinStatusWord; }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 1.
        /// </summary>
        public CryptogramType RequestedAC1Type
        {
            get { return _requestedAC1Type; }
        }

        /// <summary>
        /// Accessor to the CID obtained by GENERATE AC 1.
        /// </summary>
        public CryptogramInformationData Cid1
        {
            get
            {
                if (_cid1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.Tag == 0x80)
                    {
                        // Format 1
                        var rawCid = new byte[1];
                        Array.Copy(_tlvGenerateAC1Response.Value, 0, rawCid, 0, rawCid.Length);
                        _cid1 = new CryptogramInformationData(new TlvData(0x9F27, 1, rawCid));
                    }
                    else if (_tlvGenerateAC1Response.Tag == 0x77)
                    {
                        _cid1 = new CryptogramInformationData(_tlvGenerateAC1Response.GetTag(0x9F27));
                    }
                }
                return _cid1;
            }
        }

        /// <summary>
        /// Accessor to the ATC obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationTransactionCounter AtcFromAC1
        {
            get
            {
                if (_atcFromAC1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.Tag == 0x80)
                    {
                        // Format 1
                        var rawATC = new byte[2];
                        Array.Copy(_tlvGenerateAC1Response.Value, 1, rawATC, 0, rawATC.Length);
                        _atcFromAC1 = new ApplicationTransactionCounter(new TlvData(0x9F36, 2, rawATC));
                    }
                    else if (_tlvGenerateAC1Response.Tag == 0x77)
                    {
                        _atcFromAC1 = new ApplicationTransactionCounter(_tlvGenerateAC1Response.GetTag(0x9F36));
                    }
                }
                return _atcFromAC1;
            }
        }

        /// <summary>
        /// Accessor to the Application Cryptogram obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationCryptogram ApplicationCryptogram
        {
            get
            {
                if (_applicationCryptogram1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.Tag == 0x80)
                    {
                        // Format 1
                        var rawAC = new byte[8];
                        Array.Copy(_tlvGenerateAC1Response.Value, 0, rawAC, 0, rawAC.Length);
                        _applicationCryptogram1 = new ApplicationCryptogram(new TlvData(0x00, 8, rawAC));
                    }
                    else if (_tlvGenerateAC1Response.Tag == 0x77)
                    {
                        _applicationCryptogram1 = new ApplicationCryptogram(_tlvGenerateAC1Response.GetTag(0x9F4B));
                    }
                }
                return _applicationCryptogram1;
            }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 2.
        /// </summary>
        public CryptogramType RequestedAC2Type
        {
            get { return _requestedAC2Type; }
        }

        #endregion

        #region >> Events

        /// <summary>
        /// Event sent before execution of <see cref="GetData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetDataEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeReadApplicationDataEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterReadApplicationDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeReadLogFileEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterReadLogFileEvent;

        /// <summary>
        /// Event sent before execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeVerifyPinEvent;

        /// <summary>
        /// Event sent after execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterVerifyPinEvent;

        /// <summary>
        /// Event sent before execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeInternalAuthenticateEvent;

        /// <summary>
        /// Event sent after execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterInternalAuthenticateEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetChallengeEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetChallengeEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGenerateAC1Event;

        /// <summary>
        /// Event sent after execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGenerateAC1Event;

        /// <summary>
        /// Event sent before execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeComputeCryptographicChecksumEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterComputeCryptographicChecksumEvent;

        #endregion

        #region >> Constructors

        /// <summary>
        /// Initializes a new <see cref="EmvApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        public EmvApplication(ICardChannel cardChannel)
            : base(cardChannel)
        {
            _tlvRecords = new List<TlvData>();
            _tlvOfflineRecords = new List<TlvData>();
        }

        /// <summary>
        /// Initializes a new <see cref="EmvApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        /// <param name="tlvFromPSE"><see cref="TlvData">TLVData</see> object coming from PSE records for this application</param>
        public EmvApplication(ICardChannel cardChannel, TlvData tlvFromPSE)
            : this(cardChannel)
        {
            _tlvFromPSE = tlvFromPSE;
            if (_tlvFromPSE.HasTag(0x4F))
            {
                Aid = _tlvFromPSE.GetTag(0x4F).Value.ToHexa();
            }
        }

        #endregion

        #region >> Methods

        /// <summary>
        /// Process the GET PROCESSING OPTIONS phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetProcessingOptions()
        {
            BeforeGetProcessingOptionsEvent.Raise(this, new EmvEventArgs());

            // If PDOL 9F38 is not supplied in FCI, then used 8300 as UDC; if supplied: build the PDOL in tag 83 L V
            byte[] pdolDataValue;
            if (TlvFci.HasTag(0x9F38))
            {
                // Use PDOL to build tag 83 value
                var pdol = new DataObjectList(TlvFci.GetTag(0x9F38).Value);
                var tlvAll = new List<TlvData> { TlvFci };
                tlvAll.AddRange(TlvTerminalData);
                pdolDataValue = pdol.BuildData(tlvAll);
            }
            else
            {
                pdolDataValue = new byte[0];
            }
            // Build tag 83 with computed value
            var tlvPdolData = new TlvData(0x83, (uint)pdolDataValue.Length, pdolDataValue);

            // Execute GET PROCESSING OPTIONS
            var cAPDU = new CommandAPDU(0x80, 0xA8, 0x00, 0x00, tlvPdolData.Length + 2, tlvPdolData.ToByteArray(), 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);

            _lastStatusWord = crp.RApdu.StatusWord;

            // If GET RESPONSE needed, do it
            if (crp.RApdu.Sw1 == 0x61)
            {
                _tlvProcessingOptions = new TlvData();

                crp = new CommandResponsePair(new GetResponseCommand(crp.RApdu.Sw2));
                crp.Transmit(_cardChannel);
                _lastStatusWord = crp.RApdu.StatusWord;
            }

            // Finally, store result
            if (crp.RApdu.StatusWord == 0x9000)
            {
                _tlvProcessingOptions = new TlvData(crp.RApdu.Udr);
            }

            AfterGetProcessingOptionsEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads the file pointed by the SFI found in the FCI of the application.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadDataFile(ApplicationFileLocator.FileIdentification file)
        {
            for (var recordNumber = file.FirstRecord; recordNumber <= file.LastRecord; recordNumber++)
            {
                CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, file.Sfi, 0);
                var crp = new CommandResponsePair(cAPDU);
                crp.Transmit(_cardChannel);

                if (crp.RApdu.StatusWord == 0x9000)
                {
                    var tlv = new TlvData(crp.RApdu.Udr);
                    // Store data in list
                    _tlvRecords.Add(tlv);

                    if (tlv.Tag != 0x70)
                    {
                        throw new Exception(String.Format("EMVApplication.readData(): record is not TLV-coded with tag 70 [{0}]", tlv));
                    }

                    // If used for offline, store it in dedicated list
                    if (recordNumber - file.FirstRecord < file.OfflineNumberOfRecords)
                    {
                        // For files with SFI in the range 1 to 10, the record tag ('70') and the record length are excluded from the offline data authentication process.
                        if (file.Sfi <= 10)
                        {
                            foreach (var tlvData in tlv.SubFields)
                            {
                                _tlvOfflineRecords.Add(tlvData);
                            }
                        }
                        //For files with SFI in the range 11 to 30, the record tag ('70') and the record length are not excluded from the offline data authentication process.
                        else
                        {
                            _tlvOfflineRecords.Add(tlv);
                        }
                    }
                }
                _lastStatusWord = crp.RApdu.StatusWord;
            }
            return _lastStatusWord;
        }

        /// <summary>
        /// Process the READ APPLICATION DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadApplicationData()
        {
            BeforeReadApplicationDataEvent.Raise(this, new EmvEventArgs());

            foreach (var file in Afl.GetFiles())
            {
                ReadDataFile(file);
            }

            AfterReadApplicationDataEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetData()
        {
            BeforeGetDataEvent.Raise(this, new EmvEventArgs());

            GetData(0x9F36, ref _tlvATC);
            GetData(0x9F13, ref _tlvLastOnlineATCRegister);
            GetData(0x9F17, ref _tlvPINTryCounter);
            GetData(0x9F4F, ref _tlvLogFormat);

            AfterGetDataEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process a GET DATA to retrieve one EMV information.
        /// </summary>
        /// <param name="tag">
        ///     <list type="bullet">
        ///         <item><c>0x9F36</c> for ATC</item>
        ///         <item><c>0x9F13</c> for Last Online ATC Register</item>
        ///         <item><c>0x9F17</c> for PIN Try Counter</item>
        ///         <item><c>0x9F4F</c> for Log Format</item>
        ///     </list>
        /// </param>
        /// <param name="tlv"></param>
        /// <returns>Last status word.</returns>
        protected UInt16 GetData(UInt32 tag, ref TlvData tlv)
        {
            // Execute GET DATA instruction
            var cAPDU = new CommandAPDU(0x80, 0xCA, (byte)(tag / 0x100), (byte)(tag % 0x100), 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);
            _lastStatusWord = crp.RApdu.StatusWord;

            // Finally store rAPDU
            if (crp.RApdu.StatusWord == 0x9000)
            {
                tlv = new TlvData(crp.RApdu.Udr);
            }

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads log file of the EMV application. Records are stored.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadLogFile()
        {
            BeforeReadLogFileEvent.Raise(this, new EmvEventArgs());

            if (LogEntry == null)
            {
                throw new LogEntryNotFoundException(String.Format("EMVApplication.readLogFile(): logEntry ({0}) undefined.", _logEntry));
            }

            if (LogFormat == null)
            {
                throw new LogFormatNotFoundException(String.Format("EMVApplication.readLogFile(): logFormat ({0}) undefined.", _logFormat));
            }

            _logRecords = new List<List<TlvData>>();

            byte recordNumber = 0;
            do
            {
                recordNumber++;
                CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, LogEntry.Sfi, 0);
                var crp = new CommandResponsePair(cAPDU);
                crp.Transmit(_cardChannel);
                _lastStatusWord = crp.RApdu.StatusWord;
                if (crp.RApdu.StatusWord == 0x9000)
                {
                    var record = crp.RApdu.Udr;
                    var dataInRecord = _logFormat.ParseRawData(record);
                    _logRecords.Add(dataInRecord);
                }
            } while (_lastStatusWord == 0x9000 && recordNumber < _logEntry.CyclicFileSize);

            AfterReadLogFileEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the VERIFY PIN phase of an EMV transaction.
        /// </summary>
        /// <param name="pinBlock">PIN Block.</param>
        /// <returns>Last status word.</returns>
        public UInt16 VerifyPin(PINBlock pinBlock)
        {
            BeforeVerifyPinEvent.Raise(this, new EmvEventArgs());

            byte p2 = 0x00;
            if (pinBlock is PlaintextPINBlock)
            {
                p2 = 0x80;
            }

            // Execute the VERIFY instruction
            var cAPDU = new CommandAPDU(0x00, 0x20, 0x00, p2, (UInt32)pinBlock.PinBlock.Length, pinBlock.PinBlock);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);
            _lastStatusWord = crp.RApdu.StatusWord;
            _verifyPinStatusWord = _lastStatusWord;

            if (_lastStatusWord != 0x9000)
            {
                Tvr.CardholderVerificationFailed = true;
            }

            AfterVerifyPinEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the INTERNAL AUTHENTICATION of an EMV transaction.
        /// </summary>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 InternalAuthenticate(byte[] unpredictableNumber)
        {
            BeforeInternalAuthenticateEvent.Raise(this, new EmvEventArgs());

            _tlvInternalAuthenticateUnpredictableNumber = new TlvData(0x9F37, 0x04, unpredictableNumber);

            // Build DDOL data
            byte[] ddolDataValue;
            if (Ddol != null)
            {
                // Use DDOL to build data
                var tlvAll = new List<TlvData>
                {
                    TlvFci,
                    TlvProcessingOptions,
                    _tlvInternalAuthenticateUnpredictableNumber
                };
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                ddolDataValue = Ddol.BuildData(tlvAll);
            }
            else
            {
                ddolDataValue = new byte[0];
            }

            // Execute GET PROCESSING OPTIONS
            var cAPDU = new CommandAPDU(0x00, 0x88, 0x00, 0x00, (uint)ddolDataValue.Length, ddolDataValue, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);
            _lastStatusWord = crp.RApdu.StatusWord;

            // If GET RESPONSE needed, do it
            if (crp.RApdu.Sw1 == 0x61)
            {
                _tlvSignedDynamicApplicationResponse = new TlvData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.RApdu.Sw2));
                crp.Transmit(_cardChannel);
                _lastStatusWord = crp.RApdu.StatusWord;
            }

            // Finally, store result
            if (crp.RApdu.StatusWord == 0x9000)
            {
                _tlvSignedDynamicApplicationResponse = new TlvData(crp.RApdu.Udr);
            }

            AfterInternalAuthenticateEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET CHALLENGE of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetChallenge()
        {
            BeforeGetChallengeEvent.Raise(this, new EmvEventArgs());

            // Clear previous challenge
            _iccChallenge = null;

            // Execute GET CHALLENGE
            var cAPDU = new CommandAPDU(0x00, 0x84, 0x00, 0x00, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);
            _lastStatusWord = crp.RApdu.StatusWord;

            // If GET RESPONSE needed, do it
            if (crp.RApdu.Sw1 == 0x61)
            {
                crp = new CommandResponsePair(new GetResponseCommand(crp.RApdu.Sw2));
                _lastStatusWord = crp.RApdu.StatusWord;
            }

            // Finally, store result
            if (crp.RApdu.StatusWord == 0x9000)
            {
                _iccChallenge = crp.RApdu.Udr;
            }

            AfterGetChallengeEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GENERATE APPLICATION CRYPTOGRAM 1 of an EMV transaction.
        /// </summary>
        /// <param name="cryptogramType">Type of the cryptogram to be generated.</param>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 GenerateAc1(CryptogramType cryptogramType, byte[] unpredictableNumber)
        {
            BeforeGenerateAC1Event.Raise(this, new EmvEventArgs());

            _tlvGenerateAC1UnpredictableNumber = new TlvData(0x9F37, (uint)unpredictableNumber.Length, unpredictableNumber);

            _requestedAC1Type = cryptogramType;

            byte referenceControlParameter;
            switch (cryptogramType)
            {
                case CryptogramType.AAC:
                    referenceControlParameter = 0x00;
                    break;
                case CryptogramType.ARQC:
                    referenceControlParameter = 0x80;
                    break;
                case CryptogramType.TC:
                    referenceControlParameter = 0x40;
                    break;
                default:
                    throw new Exception(String.Format("EMVApplication.generateAC1: bad Cryptogram Type [{0}]", cryptogramType));
            }

            // TODO: if CDA signature requested, set bit 5 to 1 (0x08)

            // Build CDOL1 data
            byte[] cdolDataValue;
            if (Cdol1 != null)
            {
                // Use CDOL1 to build data
                var tlvAll = new List<TlvData> { TlvFci, TlvProcessingOptions, _tlvGenerateAC1UnpredictableNumber };
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                tlvAll.Add(Tvr.Tlv);
                cdolDataValue = Cdol1.BuildData(tlvAll);
            }
            else
            {
                cdolDataValue = new byte[0];
            }

            // Execute GENERATE AC
            var cAPDU = new CommandAPDU(0x80, 0xAE, referenceControlParameter, 0x00, (UInt32)cdolDataValue.Length, cdolDataValue, 0); // Bad APDU !
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);

            _lastStatusWord = crp.RApdu.StatusWord;

            // If GET RESPONSE needed, do it
            if (crp.RApdu.Sw1 == 0x61)
            {
                _tlvGenerateAC1Response = new TlvData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.RApdu.Sw2));
                crp.Transmit(_cardChannel);
                _lastStatusWord = crp.RApdu.StatusWord;
            }

            // Finally, store result
            if (crp.RApdu.StatusWord == 0x9000)
            {
                _tlvGenerateAC1Response = new TlvData(crp.RApdu.Udr);
            }

            AfterGenerateAC1Event.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// MasterCard cAPDU.
        /// Process the COMPUTE CRYPTOGRAPHIC CHECKSUM phase of a MasterCard transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ComputeCryptographicChecksum()
        {
            BeforeComputeCryptographicChecksumEvent.Raise(this, new EmvEventArgs());

            // If UDOL 9F69 is not supplied in records, then use default UDOL = 9F6A04
            byte[] udolDataValue = null;
            var tlvAll = new List<TlvData>();
            foreach (var record in _tlvRecords)
            {
                tlvAll.Add(record);
                if (record.HasTag(0x9F69))
                {
                    var udol = new DataObjectList(record.GetTag(0x9F69).Value);
                    tlvAll.AddRange(TlvTerminalData);
                    udolDataValue = udol.BuildData(tlvAll);
                }
            }

            if (udolDataValue == null)
            {
                var tmp = "";
                var seed = new Random(10000).Next();
                var rndNumbers = new Random(seed);
                for (var i = 0; i < 8; i++)
                {
                    var rndNumber = rndNumbers.Next(10);
                    tmp += rndNumber.ToString(CultureInfo.InvariantCulture);
                }
                udolDataValue = tmp.FromHexa();
            }

            // Execute COMPUTE CRYPTOGRAPHIC CHECKSUM
            var cAPDU = new CommandAPDU(0x80, 0x2A, 0x8E, 0x80, (uint)udolDataValue.Length, udolDataValue, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.Transmit(_cardChannel);
            _lastStatusWord = crp.RApdu.StatusWord;

            // If GET RESPONSE needed, do it
            if (crp.RApdu.Sw1 == 0x61)
            {
                _tlvCryptographicChecksum = new TlvData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.RApdu.Sw2));
                crp.Transmit(_cardChannel);
                _lastStatusWord = crp.RApdu.StatusWord;
            }

            // Finally, store result
            if (crp.RApdu.StatusWord == 0x9000)
            {
                _tlvCryptographicChecksum = new TlvData(crp.RApdu.Udr);
            }

            AfterComputeCryptographicChecksumEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        #endregion
    }
}