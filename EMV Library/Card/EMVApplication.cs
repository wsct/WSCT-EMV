using System;
using System.Collections.Generic;
using System.Text;

using WSCT.Core;
using WSCT.EMV.Commands;
using WSCT.EMV.Objects;
using WSCT.EMV.Security;
using WSCT.Helpers;
using WSCT.Helpers.BasicEncodingRules;

namespace WSCT.EMV.Card
{
    /// <summary>
    /// An <c>EMVApplication</c> instance represents an EMV application.
    /// Allows selection and use of the application.
    /// </summary>
    /// <example>
    ///     <code>
    /// ICardChannel cardChannel;
    /// // ... acquire here a valid cardChannel instance ...
    /// EMVApplication emvApp = new EMVApplication(cardChannel);
    /// emvApp.aid = "A0 00 00 00 03 10 10";
    /// emvApp.select();
    /// emvApp.getProcessingOptions();
    ///     </code>
    /// </example>
    public class EMVApplication : EMVDefinitionFile
    {
        #region >> Fields

        protected CertificationAuthorityRepository _certificationAuthorityRepository;
        protected List<TLVData> _tlvTerminalData;

        protected TerminalVerificationResult _tvr;

        protected TLVData _tlvFromPSE;
        protected TLVData _tlvProcessingOptions;
        protected ApplicationInterchangeProfile _aip;
        protected ApplicationFileLocator _afl;
        protected CardholderVerificationMethodList _cvmList;
        protected List<TLVData> _tlvRecords;
        protected List<TLVData> _tlvOfflineRecords;
        protected TLVData _tlvATC;
        protected TLVData _tlvLastOnlineATCRegister;
        protected TLVData _tlvPINTryCounter;
        protected TLVData _tlvLogFormat;
        protected TLVData _tlvCryptographicChecksum;

        protected LogEntry _logEntry;
        protected DataObjectList _logFormat;
        protected List<List<TLVData>> _logRecords;

        protected DataObjectList _ddol;
        protected DataObjectList _cdol1;
        protected DataObjectList _cdol2;

        protected PublicKey _certificationAuthorityPublicKey;
        protected IssuerPublicKeyCertificate _issuerPublicKeyCertificate;
        protected PublicKey _issuerPublicKey;
        protected IccPublicKeyCertificate _iccPublicKeyCertificate;
        protected PublicKey _iccPublicKey;

        protected StaticDataAuthentication _sda;
        protected DynamicDataAuthentication _dda;
        protected CombinedDataAuthentication _cda;

        protected TLVData _tlvInternalAuthenticateUnpredictableNumber;
        protected TLVData _tlvSignedDynamicApplicationResponse;

        protected TLVData _tlvGenerateAC1UnpredictableNumber;
        protected TLVData _tlvGenerateAC1Response;
        protected TLVData _tlvGenerateAC2Response;

        protected Byte[] _iccChallenge;

        protected UInt16 _verifyPinStatusWord;

        protected CryptogramType _requestedAC1Type;
        protected CryptogramInformationData _cid1;
        protected ApplicationTransactionCounter _atcFromAC1;
        protected ApplicationCryptogram _applicationCryptogram1;

        protected CryptogramType _requestedAC2Type;

        #endregion

        #region >> Properties

        /// <summary>
        /// Accessor to the certification authority public key repository
        /// </summary>
        public CertificationAuthorityRepository certificationAuthorityRepository
        {
            get
            {
                if (_certificationAuthorityRepository == null)
                    _certificationAuthorityRepository = new CertificationAuthorityRepository();
                return _certificationAuthorityRepository;
            }
            set { _certificationAuthorityRepository = value; }
        }

        /// <summary>
        /// Accessor to public terminal data in <see cref="TLVData"/> format
        /// </summary>
        public List<TLVData> tlvTerminalData
        {
            get
            {
                if (_tlvTerminalData == null)
                    _tlvTerminalData = new List<TLVData>();
                return _tlvTerminalData;
            }
            set { _tlvTerminalData = value; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <c>TLVData</c>
        /// </summary>
        public TLVData tlvDataTerminalData
        {
            get
            {
                TLVData tlv = new TLVData(0x00, 0x00, null);
                tlv.subFields = _tlvTerminalData;
                return tlv;
            }
        }

        /// <summary>
        /// Accessor to the Cryptographic Checksum generated by the application
        /// </summary>
        public TLVData tlvCryptographicChecksum
        {
            get { return _tlvCryptographicChecksum; }
        }

        /// <summary>
        /// Accessor to the TVR of the application
        /// </summary>
        public TerminalVerificationResult tvr
        {
            get
            {
                if (_tvr == null)
                    _tvr = new TerminalVerificationResult(new TLVData("95 05 00 00 00 00 80"));
                return _tvr;
            }
        }

        /// <summary>
        /// Accessor to the AFL of the application
        /// </summary>
        public ApplicationFileLocator afl
        {
            get
            {
                if (_afl == null && _tlvProcessingOptions != null)
                {
                    if (tlvProcessingOptions.tag == 0x80)
                    {
                        // Format 1
                        Byte[] rawAFL = new Byte[_tlvProcessingOptions.value.Length - 2];
                        Array.Copy(_tlvProcessingOptions.value, 2, rawAFL, 0, rawAFL.Length);
                        _afl = new ApplicationFileLocator(rawAFL);
                    }
                    else if (_tlvProcessingOptions.tag == 0x77)
                    {
                        _afl = new ApplicationFileLocator(_tlvProcessingOptions.getTag(0x94).value);
                    }
                }
                return _afl;
            }
        }

        /// <summary>
        /// Accessor to the AIP of the application
        /// </summary>
        public ApplicationInterchangeProfile aip
        {
            get
            {
                if (_aip == null && _tlvProcessingOptions != null)
                {
                    if (tlvProcessingOptions.tag == 0x80)
                    {
                        // Format 1
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.value[0], _tlvProcessingOptions.value[1]);
                    }
                    else if (_tlvProcessingOptions.tag == 0x77)
                    {
                        // Format 2
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.getTag(0x82).value);
                    }
                }
                return _aip;
            }
        }

        /// <summary>
        /// Accessor to the CVM list of the application
        /// </summary>
        public CardholderVerificationMethodList cvmList
        {
            get
            {
                if (_cvmList == null && _tlvRecords != null)
                {
                    foreach (TLVData record in tlvRecords)
                    {
                        if (record.hasTag(0x8E))
                        {
                            _cvmList = new CardholderVerificationMethodList(record.getTag(0x8E));
                            break;
                        }
                    }
                }
                return _cvmList;
            }
        }

        /// <summary>
        /// Accessor to the Log Entry
        /// </summary>
        public LogEntry logEntry
        {
            get
            {
                if (_logEntry == null && _tlvFCI != null && _tlvFCI.hasTag(0x9F4D))
                    _logEntry = new LogEntry(_tlvFCI.getTag(0x9F4D));
                return _logEntry;
            }
        }

        /// <summary>
        /// Accessor to the Log Format
        /// </summary>
        public DataObjectList logFormat
        {
            get
            {
                if (_logFormat == null && tlvLogFormat != null)
                    _logFormat = new DataObjectList(_tlvLogFormat.value);
                return _logFormat;
            }
        }

        /// <summary>
        /// Accessor to the records read from log file
        /// </summary>
        public List<List<TLVData>> logRecords
        {
            get { return _logRecords; }
        }

        /// <summary>
        /// Accessor to the informations coming from PSE in <c>TLVData</c> format (if available)
        /// </summary>
        public TLVData tlvFromPSE
        {
            get { return _tlvFromPSE; }
        }

        /// <summary>
        /// Accessor to the processing options in <c>TLVData</c> format
        /// </summary>
        public TLVData tlvProcessingOptions
        {
            get { return _tlvProcessingOptions; }
        }

        /// <summary>
        /// Accessor to the data read in <c>TLVData</c> format
        /// </summary>
        public List<TLVData> tlvRecords
        {
            get { return _tlvRecords; }
            set { _tlvRecords = value; }
        }

        /// <summary>
        /// Accessor to the offline signed data in <see cref="TLVData"/> format
        /// </summary>
        public List<TLVData> tlvOfflineRecords
        {
            get { return _tlvOfflineRecords; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <c>TLVData</c>
        /// </summary>
        public TLVData tlvDataRecords
        {
            get
            {
                return _tlvRecords.toTLVData(0x20);
            }
        }

        /// <summary>
        /// Accessor to ATC (obtained by GET DATA) in <c>TLVData</c> format
        /// </summary>
        public TLVData tlvATC
        {
            get { return _tlvATC; }
        }

        /// <summary>
        /// Accessor to Last Online ATC Register (obtained by GET DATA) in <c>TLVData</c> format
        /// </summary>
        public TLVData tlvLastOnlineATCRegister
        {
            get { return _tlvLastOnlineATCRegister; }
            set { _tlvLastOnlineATCRegister = value; }
        }

        /// <summary>
        /// Accessor to PIN Try Counter (obtained by GET DATA) in <c>TLVData</c> format
        /// </summary>
        public TLVData tlvPINTryCounter
        {
            get { return _tlvPINTryCounter; }
            set { _tlvPINTryCounter = value; }
        }

        /// <summary>
        /// Accessor to Log Format (obtained by GET DATA) in <c>TLVData</c> format
        /// </summary>
        public TLVData tlvLogFormat
        {
            get { return _tlvLogFormat; }
            set { _tlvLogFormat = value; }
        }

        /// <summary>
        /// Accessor to DDOL
        /// </summary>
        public DataObjectList ddol
        {
            get
            {
                if (_ddol == null && tlvDataRecords.hasTag(0x9F49))
                    _ddol = new DataObjectList(tlvDataRecords.getTag(0x9F49).value);
                return _ddol;
            }
        }

        /// <summary>
        /// Accessor to CDOL1
        /// </summary>
        public DataObjectList cdol1
        {
            get
            {
                if (_cdol1 == null && tlvDataRecords.hasTag(0x8C))
                    _cdol1 = new DataObjectList(tlvDataRecords.getTag(0x8C).value);
                return _cdol1;
            }
        }

        /// <summary>
        /// Accessor to CDOL2
        /// </summary>
        public DataObjectList cdol2
        {
            get
            {
                if (_cdol2 == null && tlvDataRecords.hasTag(0x8D))
                    _cdol2 = new DataObjectList(tlvDataRecords.getTag(0x8D).value);
                return _cdol2;
            }
        }

        /// <summary>
        /// Accessor to the Certification Authority Public Key
        /// </summary>
        public PublicKey certificationAuthorityPublicKey
        {
            get
            {
                if (_certificationAuthorityPublicKey == null && tlvDataRecords.hasTag(0x8F))
                {
                    CertificationAuthorityPublicKeyIndex caPublicKeyIndex = new CertificationAuthorityPublicKeyIndex(tlvDataRecords.getTag(0x8F));
                    ApplicationIdentifier aidObject = new ApplicationIdentifier(aid);
                    try
                    {
                        _certificationAuthorityPublicKey = certificationAuthorityRepository.get(aidObject.strRID, caPublicKeyIndex.tlv.value.toHexa());
                    }
                    catch (EMVCertificationAuthorityNotFoundException e)
                    {
                        // TODO: something when CA is not found
                    }
                }
                return _certificationAuthorityPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key Certificate
        /// </summary>
        public IssuerPublicKeyCertificate issuerPublicKeyCertificate
        {
            get
            {
                if (_issuerPublicKeyCertificate == null && certificationAuthorityPublicKey != null && tlvDataRecords.hasTag(0x90))
                {
                    _issuerPublicKeyCertificate = new IssuerPublicKeyCertificate();
                    _issuerPublicKeyCertificate.recoverFromSignature(tlvDataRecords.getTag(0x90).value, certificationAuthorityPublicKey);
                }
                return _issuerPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key (recovered from Issuer Public Key Certificate)
        /// </summary>
        public PublicKey issuerPublicKey
        {
            get
            {
                if (_issuerPublicKey == null && issuerPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    String modulus = issuerPublicKeyCertificate.publicKeyorLeftmostDigitsofthePublicKey.toHexa();
                    if (tlvDataRecords.hasTag(0x92))
                        modulus += tlvDataRecords.getTag(0x92).value.toHexa();
                    // Exponent from the ICC records
                    String exponent = tlvDataRecords.getTag(0x9F32).value.toHexa();
                    // Compute the public key
                    _issuerPublicKey = new PublicKey(modulus, exponent);
                }
                return _issuerPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key Certificate
        /// </summary>
        public IccPublicKeyCertificate iccPublicKeyCertificate
        {
            get
            {
                if (_iccPublicKeyCertificate == null && issuerPublicKey != null && tlvDataRecords.hasTag(0x9F46))
                {
                    _iccPublicKeyCertificate = new IccPublicKeyCertificate();
                    _iccPublicKeyCertificate.recoverFromSignature(tlvDataRecords.getTag(0x9F46).value, issuerPublicKey);
                }
                return _iccPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key (recovered from ICC Public Key Certificate)
        /// </summary>
        public PublicKey iccPublicKey
        {
            get
            {
                if (_iccPublicKey == null && iccPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    String modulus = iccPublicKeyCertificate.publicKeyorLeftmostDigitsofthePublicKey.toHexa();
                    if (tlvDataRecords.hasTag(0x9F48))
                        modulus += tlvDataRecords.getTag(0x9F48).value.toHexa();
                    // Exponent from the ICC records
                    String exponent = tlvDataRecords.getTag(0x9F47).value.toHexa();
                    // Compute the public key
                    _iccPublicKey = new PublicKey(modulus, exponent);
                }
                return _iccPublicKey;
            }
        }

        /// <summary>
        /// Accessor to SDA data
        /// </summary>
        public StaticDataAuthentication sda
        {
            get
            {
                if (_sda == null && tlvDataRecords.hasTag(0x93) && issuerPublicKeyCertificate != null)
                {
                    _sda = new StaticDataAuthentication();
                    _sda.recoverFromSignature(tlvDataRecords.getTag(0x93).value, issuerPublicKey);
                }
                return _sda;
            }
        }

        /// <summary>
        /// Accessor to DDA data
        /// </summary>
        public DynamicDataAuthentication dda
        {
            get
            {
                if (_dda == null && tlvSignedDynamicApplicationResponse != null && iccPublicKeyCertificate != null)
                {
                    if (tlvDataRecords.hasTag(0x8F))
                    {
                        Byte[] signature = null;
                        if (tlvSignedDynamicApplicationResponse.tag == 0x80)
                        {
                            // Format 1
                            signature = tlvSignedDynamicApplicationResponse.value;
                        }
                        else if (tlvSignedDynamicApplicationResponse.tag == 0x77)
                        {
                            // Format 2
                            signature = tlvSignedDynamicApplicationResponse.getTag(0x9F4B).value;
                        }
                        _dda = new DynamicDataAuthentication();
                        _dda.recoverFromSignature(signature, iccPublicKey);
                    }
                }
                return _dda;
            }
        }

        /// <summary>
        /// Accessor to CDA data
        /// </summary>
        public CombinedDataAuthentication cda
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for INTERNAL AUTHENTICATE (DDA)
        /// </summary>
        public TLVData tlvInternalAuthenticateUnpredictableNumber
        {
            get { return _tlvInternalAuthenticateUnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the Signed Dynamic Application rAPDU obtained by INTERNAL AUTHENTICATE
        /// </summary>
        /// <remarks>
        /// From EMV book 3:
        /// <para>Format 1: The data object returned in the rAPDU message is a primitive data object with tag equal to '80'.
        /// The value field consists of the value field of the Signed Dynamic Application Data as specified in Book 2</para>
        /// <para>Format 2: The data object returned in the rAPDU message is a constructed data object with tag equal to '77'.
        /// The value field may contain several BER-TLV coded objects, but shall always include the Signed Dynamic Application Data as specified in Book 2.</para>
        /// </remarks>
        public TLVData tlvSignedDynamicApplicationResponse
        {
            get { return _tlvSignedDynamicApplicationResponse; }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for GENERATE AC 1
        /// </summary>
        public TLVData tlvGenerateAC1UnpredictableNumber
        {
            get { return _tlvGenerateAC1UnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC1
        /// </summary>
        public TLVData tlvGenerateAC1Response
        {
            get { return _tlvGenerateAC1Response; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC2
        /// </summary>
        public TLVData tlvGenerateAC2Response
        {
            get { return _tlvGenerateAC2Response; }
        }

        /// <summary>
        /// Accessor to last GET CHALLENGE rAPDU
        /// </summary>
        public Byte[] iccChallenge
        {
            get { return _iccChallenge; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by VERIFY PIN
        /// </summary>
        public UInt16 verifyPinStatusWord
        {
            get { return _verifyPinStatusWord; }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 1
        /// </summary>
        public CryptogramType requestedAC1Type
        {
            get { return _requestedAC1Type; }
        }

        /// <summary>
        /// Accessor to the CID obtained by GENERATE AC 1
        /// </summary>
        public CryptogramInformationData cid1
        {
            get
            {
                if (_cid1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        Byte[] rawCID = new Byte[1];
                        Array.Copy(_tlvGenerateAC1Response.value, 0, rawCID, 0, rawCID.Length);
                        _cid1 = new CryptogramInformationData(new TLVData(0x9F27, 1, rawCID));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _cid1 = new CryptogramInformationData(_tlvGenerateAC1Response.getTag(0x9F27));
                    }
                }
                return _cid1;
            }
        }

        /// <summary>
        /// Accessor to the ATC obtained by GENERATE AC 1
        /// </summary>
        public ApplicationTransactionCounter atcFromAC1
        {
            get
            {
                if (_atcFromAC1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        Byte[] rawATC = new Byte[2];
                        Array.Copy(_tlvGenerateAC1Response.value, 1, rawATC, 0, rawATC.Length);
                        _atcFromAC1 = new ApplicationTransactionCounter(new TLVData(0x9F36, 2, rawATC));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _atcFromAC1 = new ApplicationTransactionCounter(_tlvGenerateAC1Response.getTag(0x9F36));
                    }
                }
                return _atcFromAC1;
            }
        }

        /// <summary>
        /// Accessor to the Application Cryptogram obtained by GENERATE AC 1
        /// </summary>
        public ApplicationCryptogram applicationCryptogram
        {
            get
            {
                if (_applicationCryptogram1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        Byte[] rawAC = new Byte[8];
                        Array.Copy(_tlvGenerateAC1Response.value, 0, rawAC, 0, rawAC.Length);
                        _applicationCryptogram1 = new ApplicationCryptogram(new TLVData(0x00, 8, rawAC));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _applicationCryptogram1 = new ApplicationCryptogram(_tlvGenerateAC1Response.getTag(0x9F4B));
                    }
                }
                return _applicationCryptogram1;
            }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 2
        /// </summary>
        public CryptogramType requestedAC2Type
        {
            get { return _requestedAC2Type; }
        }

        #endregion

        #region >> Delegates

        /// <summary>
        /// Delegate for event sent before execution of <see cref="getData()"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeGetDataEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="getData()"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterGetDataEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="getProcessingOptions"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeGetProcessingOptionsEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="getProcessingOptions"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterGetProcessingOptionsEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="readApplicationData"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeReadApplicationDataEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="readApplicationData"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterReadApplicationDataEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="readLogFile"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeReadLogFileEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="readLogFile"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterReadLogFileEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="verifyPin"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeVerifyPinEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="verifyPin"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterVerifyPinEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="internalAuthenticate"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeInternalAuthenticateEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="internalAuthenticate"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterInternalAuthenticateEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="getChallenge"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeGetChallengeEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="getChallenge"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterGetChallengeEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="generateAC1"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeGenerateAC1EventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="generateAC1"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterGenerateAC1EventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent before execution of <see cref="computeCryptographicChecksum()"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void beforeComputeCryptographicChecksumEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="computeCryptographicChecksum()"/>
        /// </summary>
        /// <param name="emv">Caller instance</param>
        public delegate void afterComputeCryptographicChecksumEventHandler(EMVApplication emv);

        #endregion

        #region >> Events

        /// <summary>
        /// Event sent before execution of <see cref="getData()"/>
        /// </summary>
        public event beforeGetDataEventHandler beforeGetDataEvent;
        /// <summary>
        /// Event sent after execution of <see cref="getData()"/>
        /// </summary>
        public event afterGetDataEventHandler afterGetDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="getProcessingOptions"/>
        /// </summary>
        public event beforeGetProcessingOptionsEventHandler beforeGetProcessingOptionsEvent;
        /// <summary>
        /// Event sent after execution of <see cref="getProcessingOptions"/>
        /// </summary>
        public event afterGetProcessingOptionsEventHandler afterGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent before execution of <see cref="readApplicationData"/>
        /// </summary>
        public event beforeReadApplicationDataEventHandler beforeReadApplicationDataEvent;
        /// <summary>
        /// Event sent after execution of <see cref="readApplicationData"/>
        /// </summary>
        public event afterReadApplicationDataEventHandler afterReadApplicationDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="readLogFile"/>
        /// </summary>
        public event beforeGetDataEventHandler beforeReadLogFileEvent;
        /// <summary>
        /// Event sent after execution of <see cref="readLogFile"/>
        /// </summary>
        public event afterGetDataEventHandler afterReadLogFileEvent;

        /// <summary>
        /// Event sent before execution of <see cref="verifyPin"/>
        /// </summary>
        public event beforeVerifyPinEventHandler beforeVerifyPinEvent;
        /// <summary>
        /// Event sent after execution of <see cref="verifyPin"/>
        /// </summary>
        public event afterVerifyPinEventHandler afterVerifyPinEvent;

        /// <summary>
        /// Event sent before execution of <see cref="internalAuthenticate"/>
        /// </summary>
        public event beforeInternalAuthenticateEventHandler beforeInternalAuthenticateEvent;
        /// <summary>
        /// Event sent after execution of <see cref="internalAuthenticate"/>
        /// </summary>
        public event afterInternalAuthenticateEventHandler afterInternalAuthenticateEvent;

        /// <summary>
        /// Event sent before execution of <see cref="getChallenge"/>
        /// </summary>
        public event beforeGetChallengeEventHandler beforeGetChallengeEvent;
        /// <summary>
        /// Event sent after execution of <see cref="getChallenge"/>
        /// </summary>
        public event afterGetChallengeEventHandler afterGetChallengeEvent;

        /// <summary>
        /// Event sent before execution of <see cref="generateAC1"/>
        /// </summary>
        public event beforeGenerateAC1EventHandler beforeGenerateAC1Event;
        /// <summary>
        /// Event sent after execution of <see cref="generateAC1"/>
        /// </summary>
        public event afterGenerateAC1EventHandler afterGenerateAC1Event;

        /// <summary>
        /// Event sent before execution of <see cref="computeCryptographicChecksum()"/>
        /// </summary>
        public event beforeComputeCryptographicChecksumEventHandler beforeComputeCryptographicChecksumEvent;
        /// <summary>
        /// Event sent after execution of <see cref="computeCryptographicChecksum()"/>
        /// </summary>
        public event afterComputeCryptographicChecksumEventHandler afterComputeCryptographicChecksumEvent;

        #endregion

        #region >> Constructors

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        public EMVApplication(ICardChannel cardChannel)
            : base(cardChannel)
        {
            _tlvRecords = new List<TLVData>();
            _tlvOfflineRecords = new List<TLVData>();
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        /// <param name="tlvFromPSE"><see cref="TLVData">TLVData</see> object coming from PSE records for this application</param>
        public EMVApplication(ICardChannel cardChannel, TLVData tlvFromPSE)
            : this(cardChannel)
        {
            _tlvFromPSE = tlvFromPSE;
            if (_tlvFromPSE.hasTag(0x4F))
            {
                aid = _tlvFromPSE.getTag(0x4F).value.toHexa();
            }
        }

        #endregion

        #region >> Methods

        /// <summary>
        /// Process the GET PROCESSING OPTIONS phase of an EMV transaction
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 getProcessingOptions()
        {
            if (beforeGetProcessingOptionsEvent != null) beforeGetProcessingOptionsEvent(this);

            // If PDOL 9F38 is not supplied in FCI, then used 8300 as UDC; if supplied: build the PDOL in tag 83 L V
            TLVData tlvPDOLData;
            Byte[] pdolDataValue;
            if (_tlvFCI.hasTag(0x9F38))
            {
                // Use PDOL to build tag 83 value
                DataObjectList pdol = new DataObjectList(_tlvFCI.getTag(0x9F38).value);
                List<TLVData> tlvAll = new List<TLVData>();
                tlvAll.Add(_tlvFCI);
                tlvAll.AddRange(tlvTerminalData);
                pdolDataValue = pdol.buildData(tlvAll);
            }
            else
            {
                pdolDataValue = new Byte[0];
            }
            // Build tag 83 with computed value
            tlvPDOLData = new TLVData(0x83, (uint)pdolDataValue.Length, pdolDataValue);

            // Execute GET PROCESSING OPTIONS
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x80, 0xA8, 0x00, 0x00, (uint)tlvPDOLData.length + 2, tlvPDOLData.toByteArray(), 0);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);

            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvProcessingOptions = new TLVData();

                crp = new ISO7816.CommandResponsePair(new ISO7816.Commands.GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvProcessingOptions = new TLVData(crp.rAPDU.udr);
            }

            if (afterGetProcessingOptionsEvent != null) afterGetProcessingOptionsEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads the file pointed by the SFI found in the FCI of the application
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 readDataFile(ApplicationFileLocator.FileIdentification file)
        {
            for (byte recordNumber = file.firstRecord; recordNumber <= file.lastRecord; recordNumber++)
            {
                ISO7816.CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, file.sfi, 0);
                ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
                crp.transmit(_cardChannel);

                TLVData PSEReadResult = new TLVData();
                if (crp.rAPDU.statusWord == 0x9000)
                {
                    TLVData tlv = new TLVData(crp.rAPDU.udr);
                    // Store data in list
                    _tlvRecords.Add(tlv);

                    if (tlv.tag != 0x70)
                        throw new Exception(String.Format("EMVApplication.readData(): record is not TLV-coded with tag 70 [{0}]", tlv));

                    // If used for offline, store it in dedicated list
                    if (recordNumber - file.firstRecord < file.offlineNumberOfRecords)
                    {
                        // For files with SFI in the range 1 to 10, the record tag ('70') and the record length are excluded from the offline data authentication process.
                        if (file.sfi <= 10)
                        {
                            foreach (TLVData tlvData in tlv.subFields)
                                _tlvOfflineRecords.Add(tlvData);
                        }
                        //For files with SFI in the range 11 to 30, the record tag ('70') and the record length are not excluded from the offline data authentication process.
                        else
                        {
                            _tlvOfflineRecords.Add(tlv);
                        }
                    }
                }
                _lastStatusWord = crp.rAPDU.statusWord;
            }
            return _lastStatusWord;
        }

        /// <summary>
        /// Process the READ APPLICATION DATA phase of an EMV transaction
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 readApplicationData()
        {
            if (beforeReadApplicationDataEvent != null) beforeReadApplicationDataEvent(this);

            foreach (ApplicationFileLocator.FileIdentification file in afl.getFiles())
            {
                readDataFile(file);
            }

            if (afterReadApplicationDataEvent != null) afterReadApplicationDataEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET DATA phase of an EMV transaction
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 getData()
        {
            if (beforeGetDataEvent != null) beforeGetDataEvent(this);

            getData(0x9F36, ref _tlvATC);
            getData(0x9F13, ref _tlvLastOnlineATCRegister);
            getData(0x9F17, ref _tlvPINTryCounter);
            getData(0x9F4F, ref _tlvLogFormat);

            if (afterGetDataEvent != null) afterGetDataEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process a GET DATA to retrieve one EMV information
        /// </summary>
        /// <param name="tag">
        ///     <list type="bullet">
        ///         <item><c>0x9F36</c> for ATC</item>
        ///         <item><c>0x9F13</c> for Last Online ATC Register</item>
        ///         <item><c>0x9F17</c> for PIN Try Counter</item>
        ///         <item><c>0x9F4F</c> for Log Format</item>
        ///     </list>
        /// </param>
        /// <param name="tlv"></param>
        /// <returns>Last status word</returns>
        protected UInt16 getData(UInt32 tag, ref TLVData tlv)
        {
            // Execute GET DATA instruction
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x80, 0xCA, (Byte)(tag / 0x100), (Byte)(tag % 0x100), 0);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // Finally store rAPDU
            if (crp.rAPDU.statusWord == 0x9000)
            {
                tlv = new TLVData(crp.rAPDU.udr);
            }

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads log file of the EMV application. Records are stored.
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 readLogFile()
        {
            if (beforeReadLogFileEvent != null) beforeReadLogFileEvent(this);

            if (logEntry == null || logFormat == null)
                throw new Exception(String.Format("EMVApplication.readLogFile(): logEntry ({0}) or logFormat ({1}) not found.", _logEntry, _logFormat));

            _logRecords = new List<List<TLVData>>();

            Byte recordNumber = 0;
            do
            {
                recordNumber++;
                ISO7816.CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, logEntry.sfi, 0);
                ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
                if (crp.rAPDU.statusWord == 0x9000)
                {
                    Byte[] record = crp.rAPDU.udr;
                    List<TLVData> dataInRecord = _logFormat.parseRawData(record);
                    _logRecords.Add(dataInRecord);
                }

            } while (_lastStatusWord == 0x9000 && recordNumber < _logEntry.cyclicFileSize);

            if (afterReadLogFileEvent != null) afterReadLogFileEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the VERIFY PIN phase of an EMV transaction
        /// </summary>
        /// <param name="pinBlock">PIN Block</param>
        /// <returns>Last status word</returns>
        public UInt16 verifyPin(PINBlock pinBlock)
        {
            if (beforeVerifyPinEvent != null) beforeVerifyPinEvent(this);

            Byte p2 = 0x00;
            if (pinBlock is PlaintextPINBlock)
                p2 = 0x80;

            // Execute the VERIFY instruction
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x00, 0x20, 0x00, p2, (UInt32)pinBlock.pinBlock.Length, pinBlock.pinBlock);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;
            _verifyPinStatusWord = _lastStatusWord;

            if (_lastStatusWord != 0x9000)
                tvr.cardholderVerificationFailed = true;

            if (afterVerifyPinEvent != null) afterVerifyPinEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the INTERNAL AUTHENTICATION of an EMV transaction
        /// </summary>
        /// <param name="unpredictableNumber">Unpredictable number</param>
        /// <returns>Last status word</returns>
        public UInt16 internalAuthenticate(Byte[] unpredictableNumber)
        {
            _tlvInternalAuthenticateUnpredictableNumber = new TLVData(0x9F37, 0x04, unpredictableNumber);

            if (beforeInternalAuthenticateEvent != null) beforeInternalAuthenticateEvent(this);

            // Build DDOL data
            Byte[] ddolDataValue;
            if (ddol != null)
            {
                // Use DDOL to build data
                List<TLVData> tlvAll = new List<TLVData>();
                tlvAll.Add(tlvFCI);
                tlvAll.Add(tlvProcessingOptions);
                tlvAll.Add(_tlvInternalAuthenticateUnpredictableNumber);
                tlvAll.AddRange(tlvRecords);
                tlvAll.AddRange(tlvTerminalData);
                ddolDataValue = ddol.buildData(tlvAll);
            }
            else
            {
                ddolDataValue = new Byte[0];
            }

            // Execute GET PROCESSING OPTIONS
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x00, 0x88, 0x00, 0x00, (uint)ddolDataValue.Length, ddolDataValue, 0);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvSignedDynamicApplicationResponse = new TLVData();
                crp = new ISO7816.CommandResponsePair(new ISO7816.Commands.GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvSignedDynamicApplicationResponse = new TLVData(crp.rAPDU.udr);
            }

            if (afterInternalAuthenticateEvent != null) afterInternalAuthenticateEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET CHALLENGE of an EMV transaction
        /// </summary>
        /// <returns>Last status word</returns>
        public UInt16 getChallenge()
        {
            if (beforeGetChallengeEvent != null) beforeGetChallengeEvent(this);

            // Clear previous challenge
            _iccChallenge = null;

            // Execute GET CHALLENGE
            ISO7816.CommandAPDU cAPDU;
            cAPDU = new ISO7816.CommandAPDU(0x00, 0x84, 0x00, 0x00, 0);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                crp = new ISO7816.CommandResponsePair(new ISO7816.Commands.GetResponseCommand(crp.rAPDU.sw2));
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _iccChallenge = crp.rAPDU.udr;
            }

            if (afterGetChallengeEvent != null) afterGetChallengeEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GENERATE APPLICATION CRYPTOGRAM 1 of an EMV transaction
        /// </summary>
        /// <param name="cryptogramType">Type of the cryptogram to be generated</param>
        /// <param name="unpredictableNumber">Unpredictable number</param>
        /// <returns>Last status word</returns>
        public UInt16 generateAC1(CryptogramType cryptogramType, Byte[] unpredictableNumber)
        {
            _tlvGenerateAC1UnpredictableNumber = new TLVData(0x9F37, (uint)unpredictableNumber.Length, unpredictableNumber);

            _requestedAC1Type = cryptogramType;

            if (beforeGenerateAC1Event != null) beforeGenerateAC1Event(this);

            Byte referenceControlParameter;
            switch (cryptogramType)
            {
                case CryptogramType.AAC:
                    referenceControlParameter = 0x00;
                    break;
                case CryptogramType.ARQC:
                    referenceControlParameter = 0x80;
                    break;
                case CryptogramType.TC:
                    referenceControlParameter = 0x40;
                    break;
                default:
                    throw new Exception(String.Format("EMVApplication.generateAC1: bad Cryptogram Type [{0}]", cryptogramType));
            }

            // TODO: if CDA signature requested, set bit 5 to 1 (0x08)

            // Build CDOL1 data
            Byte[] cdolDataValue;
            if (cdol1 != null)
            {
                // Use CDOL1 to build data
                List<TLVData> tlvAll = new List<TLVData>();
                tlvAll.Add(tlvFCI);
                tlvAll.Add(tlvProcessingOptions);
                tlvAll.Add(_tlvGenerateAC1UnpredictableNumber);
                tlvAll.AddRange(tlvRecords);
                tlvAll.AddRange(tlvTerminalData);
                tlvAll.Add(tvr.tlv);
                cdolDataValue = cdol1.buildData(tlvAll);
            }
            else
            {
                cdolDataValue = new Byte[0];
            }

            // Execute GENERATE AC
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x80, 0xAE, referenceControlParameter, 0x00, (UInt32)cdolDataValue.Length, cdolDataValue, 0); // Bad APDU !
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);

            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvGenerateAC1Response = new TLVData();
                crp = new ISO7816.CommandResponsePair(new ISO7816.Commands.GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvGenerateAC1Response = new TLVData(crp.rAPDU.udr);
            }

            if (afterGenerateAC1Event != null) afterGenerateAC1Event(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// MasterCard cAPDU.
        /// Process the COMPUTE CRYPTOGRAPHIC CHECKSUM phase of a MasterCard transaction
        /// </summary>
        /// <returns></returns>
        public UInt16 ComputeCryptographiChecksum()
        {
            if (beforeComputeCryptographicChecksumEvent != null) beforeComputeCryptographicChecksumEvent(this);

            // If UDOL 9F69 is not supplied in records, then use default UDOL = 9F6A04
            DataObjectList udol = null;
            Byte[] udolDataValue = null;
            List<TLVData> tlvAll = new List<TLVData>();
            foreach (TLVData record in _tlvRecords)
            {
                tlvAll.Add(record);
                if (record.hasTag(0x9F69))
                {
                    udol = new DataObjectList(record.getTag(0x9F69).value);
                    tlvAll.AddRange(tlvTerminalData);
                    udolDataValue = udol.buildData(tlvAll);
                }
            }

            if (udolDataValue == null)
            {
                String tmp = "";
                int seed = new Random(10000).Next();
                Random rndNumbers = new Random(seed);
                int rndNumber = 0;
                for (int i = 0; i < 8; i++)
                {
                    rndNumber = rndNumbers.Next(10);
                    tmp += rndNumber.ToString();
                }
                udolDataValue = new Byte[4];
                udolDataValue = tmp.fromHexa();
            }

            // Execute COMPUTE CRYPTOGRAPHIC CHECKSUM
            ISO7816.CommandAPDU cAPDU = new ISO7816.CommandAPDU(0x80, 0x2A, 0x8E, 0x80, (uint)udolDataValue.Length, udolDataValue, 0);
            ISO7816.CommandResponsePair crp = new ISO7816.CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvCryptographicChecksum = new TLVData();
                crp = new ISO7816.CommandResponsePair(new ISO7816.Commands.GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvCryptographicChecksum = new TLVData(crp.rAPDU.udr);
            }

            if (afterComputeCryptographicChecksumEvent != null) afterComputeCryptographicChecksumEvent(this);

            return _lastStatusWord;

        }

        #endregion
    }
}
