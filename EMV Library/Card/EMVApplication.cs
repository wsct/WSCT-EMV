using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using WSCT.Core;
using WSCT.Core.Fluent.Helpers;
using WSCT.EMV.Commands;
using WSCT.EMV.Exceptions;
using WSCT.EMV.Objects;
using WSCT.EMV.Security;
using WSCT.Helpers;
using WSCT.Helpers.BasicEncodingRules;
using WSCT.Helpers.Events;
using WSCT.ISO7816;
using WSCT.ISO7816.Commands;

namespace WSCT.EMV.Card
{
    /// <summary>
    /// An <c>EMVApplication</c> instance represents an EMV application.
    /// Allows selection and use of the application.
    /// </summary>
    /// <example>
    ///     <code>
    /// ICardChannel cardChannel;
    /// // ... acquire here a valid cardChannel instance ...
    /// EMVApplication emvApp = new EMVApplication(cardChannel);
    /// emvApp.aid = "A0 00 00 00 03 10 10";
    /// emvApp.select();
    /// emvApp.getProcessingOptions();
    ///     </code>
    /// </example>
    public class EmvApplication : EmvDefinitionFile
    {
        #region >> Fields

        protected ApplicationFileLocator _afl;
        protected ApplicationInterchangeProfile _aip;
        protected ApplicationCryptogram _applicationCryptogram1;
        protected ApplicationTransactionCounter _atcFromAC1;
        protected SignedCombinedApplicationData _cda;
        protected DataObjectList _cdol1;
        protected DataObjectList _cdol2;

        protected PublicKey _certificationAuthorityPublicKey;
        protected CertificationAuthorityRepository _certificationAuthorityRepository;
        protected CryptogramInformationData _cid1;
        protected CardholderVerificationMethodList _cvmList;
        protected SignedDynamicApplicationData _dda;
        protected DataObjectList _ddol;
        protected byte[] _iccChallenge;
        protected PublicKey _iccPublicKey;
        protected IccPublicKeyCertificate _iccPublicKeyCertificate;
        protected PublicKey _issuerPublicKey;
        protected IssuerPublicKeyCertificate _issuerPublicKeyCertificate;
        protected LogEntry _logEntry;
        protected DataObjectList _logFormat;
        protected List<List<TlvData>> _logRecords;
        protected CryptogramType _requestedAC1Type;
        protected CryptogramType _requestedAC2Type;

        protected SignedStaticApplicationData _sda;
        protected TlvData _tlvATC;
        protected TlvData _tlvCryptographicChecksum;
        protected TlvData _tlvFromPSE;
        protected TlvData _tlvGenerateAC1Response;
        protected TlvData _tlvGenerateAC1UnpredictableNumber;
        protected TlvData _tlvGenerateAC2Response;
        protected TlvData _tlvInternalAuthenticateUnpredictableNumber;
        protected TlvData _tlvLastOnlineATCRegister;
        protected TlvData _tlvLogFormat;
        protected List<TlvData> _tlvOfflineRecords;
        protected TlvData _tlvPINTryCounter;
        protected TlvData _tlvProcessingOptions;
        protected List<TlvData> _tlvRecords;
        protected TlvData _tlvSignedDynamicApplicationResponse;
        protected List<TlvData> _tlvTerminalData;

        protected TerminalVerificationResult _tvr;

        protected UInt16 _verifyPinStatusWord;

        #endregion

        #region >> Properties

        /// <summary>
        /// Accessor to the certification authority public key repository.
        /// </summary>
        public CertificationAuthorityRepository CertificationAuthorityRepository
        {
            get
            {
                _certificationAuthorityRepository ??= new CertificationAuthorityRepository();

                return _certificationAuthorityRepository;
            }
            set => _certificationAuthorityRepository = value;
        }

        /// <summary>
        /// Accessor to public terminal data in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvTerminalData
        {
            get
            {
                _tlvTerminalData ??= new List<TlvData>();

                return _tlvTerminalData;
            }
            set => _tlvTerminalData = value;
        }

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TlvData"/>.
        /// </summary>
        public TlvData TlvDataTerminalData => new(0x00, 0x00, null) { InnerTlvs = _tlvTerminalData };

        /// <summary>
        /// Accessor to the Cryptographic Checksum generated by the application.
        /// </summary>
        public TlvData TlvCryptographicChecksum => _tlvCryptographicChecksum;

        /// <summary>
        /// Accessor to the TVR of the application.
        /// </summary>
        public TerminalVerificationResult Tvr
        {
            get
            {
                _tvr ??= new TerminalVerificationResult(new TlvData("95 05 00 00 00 00 80"));

                return _tvr;
            }
        }

        /// <summary>
        /// Accessor to the AFL of the application.
        /// </summary>
        public ApplicationFileLocator Afl
        {
            get
            {
                if (_afl != null || _tlvProcessingOptions == null)
                {
                    return _afl;
                }

                _afl = TlvProcessingOptions.Tag switch
                {
                    // Format 1
                    0x80 => new ApplicationFileLocator(_tlvProcessingOptions.Value.AsSpan(2).ToArray()),
                    // Format 2
                    0x77 => new ApplicationFileLocator(_tlvProcessingOptions.GetTag(0x94).Value),
                    _ => throw new Exception($"Unexpected GPO tag [{TlvProcessingOptions}]")
                };

                return _afl;
            }
        }

        /// <summary>
        /// Accessor to the AIP of the application.
        /// </summary>
        public ApplicationInterchangeProfile Aip
        {
            get
            {
                if (_aip != null || _tlvProcessingOptions == null)
                {
                    return _aip;
                }

                _aip = TlvProcessingOptions.Tag switch
                {
                    // Format 1
                    0x80 => new ApplicationInterchangeProfile(_tlvProcessingOptions.Value[0], _tlvProcessingOptions.Value[1]),
                    // Format 2
                    0x77 => new ApplicationInterchangeProfile(_tlvProcessingOptions.GetTag(0x82).Value),
                    _ => throw new Exception($"Unexpected GPO tag [{TlvProcessingOptions}]")
                };

                return _aip;
            }
        }

        /// <summary>
        /// Accessor to the CVM list of the application.
        /// </summary>
        public CardholderVerificationMethodList CvmList
        {
            get
            {
                if (_cvmList != null || _tlvRecords == null)
                {
                    return _cvmList;
                }

                foreach (var record in TlvRecords)
                {
                    if (record.HasTag(0x8E))
                    {
                        _cvmList = new CardholderVerificationMethodList(record.GetTag(0x8E));
                        break;
                    }
                }

                return _cvmList;
            }
        }

        /// <summary>
        /// Accessor to the Log Entry.
        /// </summary>
        public LogEntry LogEntry
        {
            get
            {
                if (_logEntry != null || TlvFci == null || !TlvFci.HasTag(0x9F4D))
                {
                    return _logEntry;
                }

                _logEntry = new LogEntry(TlvFci.GetTag(0x9F4D));

                return _logEntry;
            }
        }

        /// <summary>
        /// Accessor to the Log Format.
        /// </summary>
        public DataObjectList LogFormat
        {
            get
            {
                if (_logFormat != null || TlvLogFormat == null)
                {
                    return _logFormat;
                }

                _logFormat = new DataObjectList(_tlvLogFormat.Value);

                return _logFormat;
            }
        }

        /// <summary>
        /// Accessor to the records read from log file.
        /// </summary>
        public List<List<TlvData>> LogRecords => _logRecords;

        /// <summary>
        /// Accessor to the informations coming from PSE in <see cref="TlvData"/> format (if available).
        /// </summary>
        public TlvData TlvFromPSE => _tlvFromPSE;

        /// <summary>
        /// Accessor to the processing options in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvProcessingOptions => _tlvProcessingOptions;

        /// <summary>
        /// Accessor to the data read in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvRecords => _tlvRecords;

        /// <summary>
        /// Accessor to the offline signed data in <see cref="TlvData"/> format.
        /// </summary>
        public List<TlvData> TlvOfflineRecords => _tlvOfflineRecords;

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TlvData"/>.
        /// </summary>
        public TlvData TlvDataRecords => _tlvRecords.ToTlvData(0x20);

        /// <summary>
        /// Accessor to ATC (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvATC => _tlvATC;

        /// <summary>
        /// Accessor to Last Online ATC Register (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvLastOnlineATCRegister => _tlvLastOnlineATCRegister;

        /// <summary>
        /// Accessor to PIN Try Counter (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvPINTryCounter => _tlvPINTryCounter;

        /// <summary>
        /// Accessor to Log Format (obtained by GET DATA) in <see cref="TlvData"/> format.
        /// </summary>
        public TlvData TlvLogFormat => _tlvLogFormat;

        /// <summary>
        /// Accessor to DDOL.
        /// </summary>
        public DataObjectList Ddol
        {
            get
            {
                if (_ddol != null || !TlvDataRecords.HasTag(0x9F49))
                {
                    return _ddol;
                }

                _ddol = new DataObjectList(TlvDataRecords.GetTag(0x9F49).Value);

                return _ddol;
            }
        }

        /// <summary>
        /// Accessor to CDOL1.
        /// </summary>
        public DataObjectList Cdol1
        {
            get
            {
                if (_cdol1 != null || !TlvDataRecords.HasTag(0x8C))
                {
                    return _cdol1;
                }

                _cdol1 = new DataObjectList(TlvDataRecords.GetTag(0x8C).Value);

                return _cdol1;
            }
        }

        /// <summary>
        /// Accessor to CDOL2.
        /// </summary>
        public DataObjectList Cdol2
        {
            get
            {
                if (_cdol2 != null || !TlvDataRecords.HasTag(0x8D))
                {
                    return _cdol2;
                }

                _cdol2 = new DataObjectList(TlvDataRecords.GetTag(0x8D).Value);

                return _cdol2;
            }
        }

        /// <summary>
        /// Accessor to the Certification Authority Public Key.
        /// </summary>
        public PublicKey CertificationAuthorityPublicKey
        {
            get
            {
                if (_certificationAuthorityPublicKey != null || !TlvDataRecords.HasTag(0x8F))
                {
                    return _certificationAuthorityPublicKey;
                }

                var caPublicKeyIndex = new CertificationAuthorityPublicKeyIndex(TlvDataRecords.GetTag(0x8F));
                var aidObject = new ApplicationIdentifier(Aid);
                try
                {
                    _certificationAuthorityPublicKey = CertificationAuthorityRepository.Get(aidObject.Rid, caPublicKeyIndex.Tlv.Value.ToHexa());
                }
                catch (EMVCertificationAuthorityNotFoundException)
                {
                    // TODO: something when CA is not found
                }

                return _certificationAuthorityPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key Certificate.
        /// </summary>
        public IssuerPublicKeyCertificate IssuerPublicKeyCertificate
        {
            get
            {
                if (_issuerPublicKeyCertificate != null || CertificationAuthorityPublicKey == null || !TlvDataRecords.HasTag(0x90))
                {
                    return _issuerPublicKeyCertificate;
                }

                _issuerPublicKeyCertificate = new IssuerPublicKeyCertificate();
                _issuerPublicKeyCertificate.RecoverFromSignature(TlvDataRecords.GetTag(0x90).Value, CertificationAuthorityPublicKey);

                return _issuerPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key (recovered from Issuer Public Key Certificate).
        /// </summary>
        public PublicKey IssuerPublicKey
        {
            get
            {
                if (_issuerPublicKey != null || IssuerPublicKeyCertificate == null)
                {
                    return _issuerPublicKey;
                }

                // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                var modulus = IssuerPublicKeyCertificate.PublicKeyorLeftmostDigitsofthePublicKey.ToHexa();
                if (TlvDataRecords.HasTag(0x92))
                {
                    modulus += TlvDataRecords.GetTag(0x92).Value.ToHexa();
                }

                // Exponent from the ICC records
                var exponent = TlvDataRecords.GetTag(0x9F32).Value.ToHexa();

                // Compute the public key
                _issuerPublicKey = new PublicKey(modulus, exponent);

                return _issuerPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key Certificate.
        /// </summary>
        public IccPublicKeyCertificate IccPublicKeyCertificate
        {
            get
            {
                if (_iccPublicKeyCertificate != null || IssuerPublicKey == null || !TlvDataRecords.HasTag(0x9F46))
                {
                    return _iccPublicKeyCertificate;
                }

                _iccPublicKeyCertificate = new IccPublicKeyCertificate();
                _iccPublicKeyCertificate.RecoverFromSignature(TlvDataRecords.GetTag(0x9F46).Value, IssuerPublicKey);

                return _iccPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key (recovered from ICC Public Key Certificate).
        /// </summary>
        public PublicKey IccPublicKey
        {
            get
            {
                if (_iccPublicKey != null || IccPublicKeyCertificate == null)
                {
                    return _iccPublicKey;
                }

                // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                var modulus = IccPublicKeyCertificate.PublicKeyorLeftmostDigitsofthePublicKey.ToHexa();
                if (TlvDataRecords.HasTag(0x9F48))
                {
                    modulus += TlvDataRecords.GetTag(0x9F48).Value.ToHexa();
                }

                // Exponent from the ICC records
                var exponent = TlvDataRecords.GetTag(0x9F47).Value.ToHexa();

                // Compute the public key
                _iccPublicKey = new PublicKey(modulus, exponent);

                return _iccPublicKey;
            }
        }

        /// <summary>
        /// Accessor to SDA data.
        /// </summary>
        public SignedStaticApplicationData Sda
        {
            get
            {
                if (_sda != null || !TlvDataRecords.HasTag(0x93) || IssuerPublicKeyCertificate == null)
                {
                    return _sda;
                }

                _sda = new SignedStaticApplicationData();
                _sda.RecoverFromSignature(TlvDataRecords.GetTag(0x93).Value, IssuerPublicKey);

                return _sda;
            }
        }

        /// <summary>
        /// Accessor to DDA data.
        /// </summary>
        public virtual SignedDynamicApplicationData Dda
        {
            get
            {
                if (_dda != null || TlvSignedDynamicApplicationResponse == null || IccPublicKeyCertificate == null)
                {
                    return _dda;
                }

                if (!TlvDataRecords.HasTag(0x8F))
                {
                    return _dda;
                }

                byte[] signature = _tlvSignedDynamicApplicationResponse.Tag switch
                {
                    0x80 => TlvSignedDynamicApplicationResponse.Value,// Format 1
                    0x77 => TlvSignedDynamicApplicationResponse.GetTag(0x9F4B).Value,// Format 2
                    _ => throw new Exception($"Unexpected Signed Dynamic Application Response tag [{_tlvSignedDynamicApplicationResponse}]"),
                };

                _dda = new SignedDynamicApplicationData();
                _dda.RecoverFromSignature(signature, IccPublicKey);

                return _dda;
            }
        }

        /// <summary>
        /// Accessor to CDA data.
        /// </summary>
        public SignedCombinedApplicationData Cda => throw new NotImplementedException();

        /// <summary>
        /// Accessor to the unpredictable number used for INTERNAL AUTHENTICATE (DDA).
        /// </summary>
        public TlvData TlvInternalAuthenticateUnpredictableNumber => _tlvInternalAuthenticateUnpredictableNumber;

        /// <summary>
        /// Accessor to the Signed Dynamic Application rAPDU obtained by INTERNAL AUTHENTICATE.
        /// </summary>
        /// <remarks>
        /// From EMV book 3:
        /// <para>Format 1: The data object returned in the rAPDU message is a primitive data object with tag equal to '80'.
        /// The value field consists of the value field of the Signed Dynamic Application Data as specified in Book 2</para>
        /// <para>Format 2: The data object returned in the rAPDU message is a constructed data object with tag equal to '77'.
        /// The value field may contain several BER-TLV coded objects, but shall always include the Signed Dynamic Application Data as specified in Book 2.</para>
        /// </remarks>
        public TlvData TlvSignedDynamicApplicationResponse => _tlvSignedDynamicApplicationResponse;

        /// <summary>
        /// Accessor to the unpredictable number used for GENERATE AC 1.
        /// </summary>
        public TlvData TlvGenerateAC1UnpredictableNumber => _tlvGenerateAC1UnpredictableNumber;

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC1.
        /// </summary>
        public TlvData TlvGenerateAC1Response => _tlvGenerateAC1Response;

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC2.
        /// </summary>
        public TlvData TlvGenerateAC2Response => _tlvGenerateAC2Response;

        /// <summary>
        /// Accessor to last GET CHALLENGE rAPDU.
        /// </summary>
        public byte[] IccChallenge => _iccChallenge;

        /// <summary>
        /// Accessor to the rAPDU obtained by VERIFY PIN.
        /// </summary>
        public UInt16 VerifyPinStatusWord => _verifyPinStatusWord;

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 1.
        /// </summary>
        public CryptogramType RequestedAC1Type => _requestedAC1Type;

        /// <summary>
        /// Accessor to the CID obtained by GENERATE AC 1.
        /// </summary>
        public CryptogramInformationData Cid1
        {
            get
            {
                if (_cid1 != null || _tlvGenerateAC1Response == null)
                {
                    return _cid1;
                }

                _cid1 = _tlvGenerateAC1Response.Tag switch
                {
                    // Format 1
                    0x80 => new CryptogramInformationData(new TlvData(0x9F27, 1, _tlvGenerateAC1Response.Value.AsSpan(0, 1).ToArray())),
                    // Format 2
                    0x77 => new CryptogramInformationData(_tlvGenerateAC1Response.GetTag(0x9F27)),
                    _ => throw new Exception($"Unexpected Generate AC1 response tag [{_tlvGenerateAC1Response}]"),
                };

                return _cid1;
            }
        }

        /// <summary>
        /// Accessor to the ATC obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationTransactionCounter AtcFromAC1
        {
            get
            {
                if (_atcFromAC1 != null || _tlvGenerateAC1Response == null)
                {
                    return _atcFromAC1;
                }

                _atcFromAC1 = _tlvGenerateAC1Response.Tag switch
                {
                    // Format 1
                    0x80 => new ApplicationTransactionCounter(new TlvData(0x9F36, 2, _tlvGenerateAC1Response.Value.AsSpan(1, 2).ToArray())),
                    // Format 2
                    0x77 => new ApplicationTransactionCounter(_tlvGenerateAC1Response.GetTag(0x9F36)),
                    _ => throw new Exception($"Unexpected Generate AC1 response tag [{_tlvGenerateAC1Response}]"),
                };

                return _atcFromAC1;
            }
        }

        /// <summary>
        /// Accessor to the Application Cryptogram obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationCryptogram ApplicationCryptogram
        {
            get
            {
                if (_applicationCryptogram1 != null || _tlvGenerateAC1Response == null)
                {
                    return _applicationCryptogram1;
                }

                _applicationCryptogram1 = _tlvGenerateAC1Response.Tag switch
                {
                    // Format 1
                    0x80 => new ApplicationCryptogram(new TlvData(0x00, 8, _tlvGenerateAC1Response.Value.AsSpan(3, 8).ToArray())),
                    // Format 2
                    0x77 => new ApplicationCryptogram(_tlvGenerateAC1Response.GetTag(0x9F4B)),
                    _ => throw new Exception($"Unexpected Generate AC1 response tag [{_tlvGenerateAC1Response}]"),
                };

                return _applicationCryptogram1;
            }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 2.
        /// </summary>
        public CryptogramType RequestedAC2Type => _requestedAC2Type;

        #endregion

        #region >> Events

        /// <summary>
        /// Event sent before execution of <see cref="GetData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetDataEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeReadApplicationDataEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterReadApplicationDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeReadLogFileEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterReadLogFileEvent;

        /// <summary>
        /// Event sent before execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeVerifyPinEvent;

        /// <summary>
        /// Event sent after execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterVerifyPinEvent;

        /// <summary>
        /// Event sent before execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeInternalAuthenticateEvent;

        /// <summary>
        /// Event sent after execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterInternalAuthenticateEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGetChallengeEvent;

        /// <summary>
        /// Event sent after execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGetChallengeEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeGenerateAC1Event;

        /// <summary>
        /// Event sent after execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterGenerateAC1Event;

        /// <summary>
        /// Event sent before execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> BeforeComputeCryptographicChecksumEvent;

        /// <summary>
        /// Event sent after execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event EventHandler<EmvEventArgs> AfterComputeCryptographicChecksumEvent;

        #endregion

        #region >> Constructors

        /// <summary>
        /// Initializes a new <see cref="EmvApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        public EmvApplication(ICardChannel cardChannel)
            : base(cardChannel)
        {
            _tlvRecords = new List<TlvData>();
            _tlvOfflineRecords = new List<TlvData>();
        }

        /// <summary>
        /// Initializes a new <see cref="EmvApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        /// <param name="tlvFromPSE"><see cref="TlvData">TLVData</see> object coming from PSE records for this application</param>
        public EmvApplication(ICardChannel cardChannel, TlvData tlvFromPSE)
            : this(cardChannel)
        {
            _tlvFromPSE = tlvFromPSE;
            if (_tlvFromPSE.HasTag(0x4F))
            {
                Aid = _tlvFromPSE.GetTag(0x4F).Value.ToHexa();
            }
        }

        #endregion

        #region >> Methods

        /// <summary>
        /// Process the GET PROCESSING OPTIONS phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetProcessingOptions()
        {
            BeforeGetProcessingOptionsEvent.Raise(this, new EmvEventArgs());

            // If PDOL 9F38 is not supplied in FCI, then used 8300 as UDC; if supplied: build the PDOL in tag 83 L V
            byte[] pdolDataValue;
            if (TlvFci.HasTag(0x9F38))
            {
                // Use PDOL to build tag 83 value
                var pdol = new DataObjectList(TlvFci.GetTag(0x9F38).Value);
                var tlvAll = new List<TlvData> { TlvFci };
                tlvAll.AddRange(TlvTerminalData);
                pdolDataValue = pdol.BuildData(tlvAll);
            }
            else
            {
                pdolDataValue = Array.Empty<byte>();
            }

            // Build tag 83 with computed value
            var tlvPdolData = new TlvData(0x83, (uint)pdolDataValue.Length, pdolDataValue);

            // Execute GET PROCESSING OPTIONS
            var crp = new CommandAPDU(0x80, 0xA8, 0x00, 0x00, tlvPdolData.Length + 2, tlvPdolData.ToByteArray(), 0)
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord)
                .OnStatusWord(0x9000, (_, r) => _tlvProcessingOptions = new TlvData(r.Udr));

            AfterGetProcessingOptionsEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads the file pointed by the SFI found in the FCI of the application.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadDataFile(AflEntry file)
        {
            for (var recordNumber = file.FirstRecord; recordNumber <= file.LastRecord; recordNumber++)
            {
                var crp = new EMVReadRecordCommand(recordNumber, file.Sfi, 0)
                    .Transmit(_cardChannel)
                    .WithResponse(r => _lastStatusWord = r.StatusWord);

                if (crp.RApdu.StatusWord == 0x9000)
                {
                    var tlv = new TlvData(crp.RApdu.Udr);

                    if (tlv.Tag != 0x70)
                    {
                        throw new Exception($"EMVApplication.readData(): record is not TLV-coded with tag 70 [{tlv}]");
                    }

                    // Store data in list
                    _tlvRecords.Add(tlv);

                    // If used for offline, store it in dedicated list
                    if (recordNumber - file.FirstRecord < file.OfflineNumberOfRecords)
                    {
                        // For files with SFI in the range 1 to 10, the record tag ('70') and the record length are excluded from the offline data authentication process.
                        if (file.Sfi <= 10)
                        {
                            _tlvOfflineRecords.AddRange(tlv.InnerTlvs);
                        }
                        //For files with SFI in the range 11 to 30, the record tag ('70') and the record length are not excluded from the offline data authentication process.
                        else
                        {
                            _tlvOfflineRecords.Add(tlv);
                        }
                    }
                }
            }

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the READ APPLICATION DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadApplicationData()
        {
            BeforeReadApplicationDataEvent.Raise(this, new EmvEventArgs());

            foreach (var file in Afl.Files)
            {
                ReadDataFile(file);
            }

            AfterReadApplicationDataEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetData()
        {
            BeforeGetDataEvent.Raise(this, new EmvEventArgs());

            GetData(0x9F36, ref _tlvATC);
            GetData(0x9F13, ref _tlvLastOnlineATCRegister);
            GetData(0x9F17, ref _tlvPINTryCounter);
            GetData(0x9F4F, ref _tlvLogFormat);

            AfterGetDataEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process a GET DATA to retrieve one EMV information.
        /// </summary>
        /// <param name="tag">
        ///     <list type="bullet">
        ///         <item><c>0x9F36</c> for ATC</item>
        ///         <item><c>0x9F13</c> for Last Online ATC Register</item>
        ///         <item><c>0x9F17</c> for PIN Try Counter</item>
        ///         <item><c>0x9F4F</c> for Log Format</item>
        ///     </list>
        /// </param>
        /// <param name="tlv"></param>
        /// <returns>Last status word.</returns>
        protected UInt16 GetData(UInt32 tag, ref TlvData tlv)
        {
            // Execute GET DATA instruction
            var crp = new GetDataCommand(tag, 0) { Cla = 0x80 }
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord);

            // Finally store rAPDU
            if (crp.RApdu.StatusWord == 0x9000)
            {
                tlv = new TlvData(crp.RApdu.Udr);
            }

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads log file of the EMV application. Records are stored.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadLogFile()
        {
            BeforeReadLogFileEvent.Raise(this, new EmvEventArgs());

            if (LogEntry == null)
            {
                throw new LogEntryNotFoundException($"EMVApplication.readLogFile(): logEntry ({_logEntry}) undefined.");
            }

            if (LogFormat == null)
            {
                throw new LogFormatNotFoundException($"EMVApplication.readLogFile(): logFormat ({_logFormat}) undefined.");
            }

            _logRecords = new List<List<TlvData>>();

            byte recordNumber = 0;
            do
            {
                recordNumber++;
                var crp = new EMVReadRecordCommand(recordNumber, LogEntry.Sfi, 0)
                    .Transmit(_cardChannel)
                    .WithResponse(r => _lastStatusWord = r.StatusWord)
                    .OnStatusWord(0x9000, (_, r) => _logRecords.Add(_logFormat.ParseRawData(r.Udr)));
            }
            while (_lastStatusWord == 0x9000 && recordNumber < _logEntry.CyclicFileSize);

            AfterReadLogFileEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the VERIFY PIN phase of an EMV transaction.
        /// </summary>
        /// <param name="pinBlock">PIN Block.</param>
        /// <returns>Last status word.</returns>
        public UInt16 VerifyPin(PINBlock pinBlock)
        {
            BeforeVerifyPinEvent.Raise(this, new EmvEventArgs());

            byte p2 = 0x00;
            if (pinBlock is PlaintextPINBlock)
            {
                p2 = 0x80;
            }

            // Execute the VERIFY instruction
            var crp = new CommandAPDU(0x00, 0x20, 0x00, p2, (UInt32)pinBlock.PinBlock.Length, pinBlock.PinBlock)
                .Transmit(_cardChannel)
                .WithResponse(r =>
                {
                    _lastStatusWord = r.StatusWord;
                    _verifyPinStatusWord = _lastStatusWord;
                })
                .OnStatusWord(sw => sw != 0x9000, (_, _) => Tvr.CardholderVerificationFailed = true);

            AfterVerifyPinEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the INTERNAL AUTHENTICATION of an EMV transaction.
        /// </summary>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 InternalAuthenticate(byte[] unpredictableNumber)
        {
            BeforeInternalAuthenticateEvent.Raise(this, new EmvEventArgs());

            _tlvInternalAuthenticateUnpredictableNumber = new TlvData(0x9F37, 0x04, unpredictableNumber);

            // Build DDOL data
            byte[] ddolDataValue;
            if (Ddol != null)
            {
                // Use DDOL to build data
                var tlvAll = new List<TlvData>
                {
                    TlvFci,
                    TlvProcessingOptions,
                    _tlvInternalAuthenticateUnpredictableNumber
                };
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                ddolDataValue = Ddol.BuildData(tlvAll);
            }
            else
            {
                ddolDataValue = Array.Empty<byte>();
            }

            // Execute GET PROCESSING OPTIONS
            var crp = new CommandAPDU(0x00, 0x88, 0x00, 0x00, (uint)ddolDataValue.Length, ddolDataValue, 0)
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord)
                .OnStatusWord(0x9000, (_, r) => _tlvSignedDynamicApplicationResponse = new TlvData(r.Udr));

            AfterInternalAuthenticateEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET CHALLENGE of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetChallenge()
        {
            BeforeGetChallengeEvent.Raise(this, new EmvEventArgs());

            // Clear previous challenge
            _iccChallenge = null;

            // Execute GET CHALLENGE
            var crp = new CommandAPDU(0x00, 0x84, 0x00, 0x00, 0)
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord)
                .OnStatusWord(0x9000, (_, r) => _iccChallenge = r.Udr);

            AfterGetChallengeEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GENERATE APPLICATION CRYPTOGRAM 1 of an EMV transaction.
        /// </summary>
        /// <param name="cryptogramType">Type of the cryptogram to be generated.</param>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 GenerateAc1(CryptogramType cryptogramType, byte[] unpredictableNumber)
        {
            BeforeGenerateAC1Event.Raise(this, new EmvEventArgs());

            _tlvGenerateAC1UnpredictableNumber = new TlvData(0x9F37, (uint)unpredictableNumber.Length, unpredictableNumber);

            _requestedAC1Type = cryptogramType;
            var referenceControlParameter = cryptogramType switch
            {
                CryptogramType.AAC => (byte)0x00,
                CryptogramType.ARQC => (byte)0x80,
                CryptogramType.TC => (byte)0x40,
                _ => throw new Exception($"EMVApplication.generateAC1: Unknown Cryptogram Type [{cryptogramType}]"),
            };

            // TODO: if CDA signature requested, set bit 5 to 1 (0x08)

            // Build CDOL1 data
            byte[] cdolDataValue;
            if (Cdol1 != null)
            {
                // Use CDOL1 to build data
                var tlvAll = new List<TlvData> { TlvFci, TlvProcessingOptions, _tlvGenerateAC1UnpredictableNumber };
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                tlvAll.Add(Tvr.Tlv);
                cdolDataValue = Cdol1.BuildData(tlvAll);
            }
            else
            {
                cdolDataValue = Array.Empty<byte>();
            }

            // Execute GENERATE AC
            var crp = new CommandAPDU(0x80, 0xAE, referenceControlParameter, 0x00, (uint)cdolDataValue.Length, cdolDataValue, 0) // TODO Bad APDU ! (?)
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord)
                .OnStatusWord(0x9000, (_, r) => _tlvGenerateAC1Response = new TlvData(r.Udr));

            AfterGenerateAC1Event.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        /// <summary>
        /// MasterCard cAPDU.
        /// Process the COMPUTE CRYPTOGRAPHIC CHECKSUM phase of a MasterCard transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ComputeCryptographicChecksum()
        {
            BeforeComputeCryptographicChecksumEvent.Raise(this, new EmvEventArgs());

            // If UDOL 9F69 is not supplied in records, then use default UDOL = 9F6A04
            byte[] udolDataValue = null;
            var tlvAll = new List<TlvData>();
            foreach (var record in _tlvRecords)
            {
                tlvAll.Add(record);
                if (record.HasTag(0x9F69))
                {
                    var udol = new DataObjectList(record.GetTag(0x9F69).Value);
                    tlvAll.AddRange(TlvTerminalData);
                    udolDataValue = udol.BuildData(tlvAll);
                }
            }

            if (udolDataValue == null)
            {
                udolDataValue = new byte[4];
                var rndNumbers = RandomNumberGenerator.Create();
                rndNumbers.GetBytes(udolDataValue);
            }

            // Execute COMPUTE CRYPTOGRAPHIC CHECKSUM
            var crp = new CommandAPDU(0x80, 0x2A, 0x8E, 0x80, (uint)udolDataValue.Length, udolDataValue, 0)
                .Transmit(_cardChannel)
                .WithResponse(r => _lastStatusWord = r.StatusWord)
                .OnStatusWord(0x9000, (_, r) => _tlvCryptographicChecksum = new TlvData(r.Udr));

            AfterComputeCryptographicChecksumEvent.Raise(this, new EmvEventArgs());

            return _lastStatusWord;
        }

        #endregion
    }
}