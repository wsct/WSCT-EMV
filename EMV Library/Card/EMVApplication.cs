using System;
using System.Collections.Generic;
using System.Globalization;
using WSCT.Core;
using WSCT.EMV.Commands;
using WSCT.EMV.Exceptions;
using WSCT.EMV.Objects;
using WSCT.EMV.Security;
using WSCT.Helpers;
using WSCT.Helpers.BasicEncodingRules;
using WSCT.ISO7816;
using WSCT.ISO7816.Commands;

namespace WSCT.EMV.Card
{
    /// <summary>
    /// An <c>EMVApplication</c> instance represents an EMV application.
    /// Allows selection and use of the application.
    /// </summary>
    /// <example>
    ///     <code>
    /// ICardChannel cardChannel;
    /// // ... acquire here a valid cardChannel instance ...
    /// EMVApplication emvApp = new EMVApplication(cardChannel);
    /// emvApp.aid = "A0 00 00 00 03 10 10";
    /// emvApp.select();
    /// emvApp.getProcessingOptions();
    ///     </code>
    /// </example>
    public class EMVApplication : EMVDefinitionFile
    {
        #region >> Fields

        protected CertificationAuthorityRepository _certificationAuthorityRepository;
        protected List<TLVData> _tlvTerminalData;

        protected TerminalVerificationResult _tvr;
        protected TLVData _tlvFromPSE;
        protected TLVData _tlvProcessingOptions;
        protected ApplicationInterchangeProfile _aip;
        protected ApplicationFileLocator _afl;
        protected CardholderVerificationMethodList _cvmList;
        protected List<TLVData> _tlvRecords;
        protected List<TLVData> _tlvOfflineRecords;
        protected TLVData _tlvATC;
        protected TLVData _tlvLastOnlineATCRegister;
        protected TLVData _tlvPINTryCounter;
        protected TLVData _tlvLogFormat;
        protected TLVData _tlvCryptographicChecksum;

        protected LogEntry _logEntry;
        protected DataObjectList _logFormat;
        protected List<List<TLVData>> _logRecords;

        protected DataObjectList _ddol;
        protected DataObjectList _cdol1;
        protected DataObjectList _cdol2;

        protected PublicKey _certificationAuthorityPublicKey;
        protected IssuerPublicKeyCertificate _issuerPublicKeyCertificate;
        protected PublicKey _issuerPublicKey;
        protected IccPublicKeyCertificate _iccPublicKeyCertificate;
        protected PublicKey _iccPublicKey;

        protected StaticDataAuthentication _sda;
        protected DynamicDataAuthentication _dda;
        protected CombinedDataAuthentication _cda;

        protected TLVData _tlvInternalAuthenticateUnpredictableNumber;
        protected TLVData _tlvSignedDynamicApplicationResponse;

        protected TLVData _tlvGenerateAC1UnpredictableNumber;
        protected TLVData _tlvGenerateAC1Response;
        protected TLVData _tlvGenerateAC2Response;

        protected Byte[] _iccChallenge;

        protected UInt16 _verifyPinStatusWord;

        protected CryptogramType _requestedAC1Type;
        protected CryptogramInformationData _cid1;
        protected ApplicationTransactionCounter _atcFromAC1;
        protected ApplicationCryptogram _applicationCryptogram1;

        protected CryptogramType _requestedAC2Type;

        #endregion

        #region >> Properties

        /// <summary>
        /// Accessor to the certification authority public key repository.
        /// </summary>
        public CertificationAuthorityRepository CertificationAuthorityRepository
        {
            get
            {
                if (_certificationAuthorityRepository == null)
                {
                    _certificationAuthorityRepository = new CertificationAuthorityRepository();
                }
                return _certificationAuthorityRepository;
            }
            set { _certificationAuthorityRepository = value; }
        }

        /// <summary>
        /// Accessor to public terminal data in <see cref="TLVData"/> format.
        /// </summary>
        public List<TLVData> TlvTerminalData
        {
            get
            {
                if (_tlvTerminalData == null)
                {
                    _tlvTerminalData = new List<TLVData>();
                }
                return _tlvTerminalData;
            }
            set { _tlvTerminalData = value; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TLVData"/>.
        /// </summary>
        public TLVData TlvDataTerminalData
        {
            get
            {
                return new TLVData(0x00, 0x00, null) { subFields = _tlvTerminalData };
            }
        }

        /// <summary>
        /// Accessor to the Cryptographic Checksum generated by the application.
        /// </summary>
        public TLVData TlvCryptographicChecksum
        {
            get { return _tlvCryptographicChecksum; }
        }

        /// <summary>
        /// Accessor to the TVR of the application.
        /// </summary>
        public TerminalVerificationResult Tvr
        {
            get
            {
                if (_tvr == null)
                {
                    _tvr = new TerminalVerificationResult(new TLVData("95 05 00 00 00 00 80"));
                }

                return _tvr;
            }
        }

        /// <summary>
        /// Accessor to the AFL of the application.
        /// </summary>
        public ApplicationFileLocator Afl
        {
            get
            {
                if (_afl == null && _tlvProcessingOptions != null)
                {
                    if (TlvProcessingOptions.tag == 0x80)
                    {
                        // Format 1
                        var rawAfl = new Byte[_tlvProcessingOptions.value.Length - 2];
                        Array.Copy(_tlvProcessingOptions.value, 2, rawAfl, 0, rawAfl.Length);
                        _afl = new ApplicationFileLocator(rawAfl);
                    }
                    else if (_tlvProcessingOptions.tag == 0x77)
                    {
                        _afl = new ApplicationFileLocator(_tlvProcessingOptions.getTag(0x94).value);
                    }
                }
                return _afl;
            }
        }

        /// <summary>
        /// Accessor to the AIP of the application.
        /// </summary>
        public ApplicationInterchangeProfile Aip
        {
            get
            {
                if (_aip == null && _tlvProcessingOptions != null)
                {
                    if (TlvProcessingOptions.tag == 0x80)
                    {
                        // Format 1
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.value[0], _tlvProcessingOptions.value[1]);
                    }
                    else if (_tlvProcessingOptions.tag == 0x77)
                    {
                        // Format 2
                        _aip = new ApplicationInterchangeProfile(_tlvProcessingOptions.getTag(0x82).value);
                    }
                }
                return _aip;
            }
        }

        /// <summary>
        /// Accessor to the CVM list of the application.
        /// </summary>
        public CardholderVerificationMethodList CvmList
        {
            get
            {
                if (_cvmList == null && _tlvRecords != null)
                {
                    foreach (var record in TlvRecords)
                    {
                        if (record.hasTag(0x8E))
                        {
                            _cvmList = new CardholderVerificationMethodList(record.getTag(0x8E));
                            break;
                        }
                    }
                }
                return _cvmList;
            }
        }

        /// <summary>
        /// Accessor to the Log Entry.
        /// </summary>
        public LogEntry LogEntry
        {
            get
            {
                if (_logEntry == null && TlvFci != null && TlvFci.hasTag(0x9F4D))
                    _logEntry = new LogEntry(TlvFci.getTag(0x9F4D));
                return _logEntry;
            }
        }

        /// <summary>
        /// Accessor to the Log Format.
        /// </summary>
        public DataObjectList LogFormat
        {
            get
            {
                if (_logFormat == null && TlvLogFormat != null)
                    _logFormat = new DataObjectList(_tlvLogFormat.value);
                return _logFormat;
            }
        }

        /// <summary>
        /// Accessor to the records read from log file.
        /// </summary>
        public List<List<TLVData>> LogRecords
        {
            get { return _logRecords; }
        }

        /// <summary>
        /// Accessor to the informations coming from PSE in <see cref="TLVData"/> format (if available).
        /// </summary>
        public TLVData TlvFromPSE
        {
            get { return _tlvFromPSE; }
        }

        /// <summary>
        /// Accessor to the processing options in <see cref="TLVData"/> format.
        /// </summary>
        public TLVData TlvProcessingOptions
        {
            get { return _tlvProcessingOptions; }
        }

        /// <summary>
        /// Accessor to the data read in <see cref="TLVData"/> format.
        /// </summary>
        public List<TLVData> TlvRecords
        {
            get { return _tlvRecords; }
            set { _tlvRecords = value; }
        }

        /// <summary>
        /// Accessor to the offline signed data in <see cref="TLVData"/> format.
        /// </summary>
        public List<TLVData> TlvOfflineRecords
        {
            get { return _tlvOfflineRecords; }
        }

        /// <summary>
        /// Accessor to the data read in a fictive <see cref="TLVData"/>.
        /// </summary>
        public TLVData TlvDataRecords
        {
            get
            {
                return _tlvRecords.toTLVData(0x20);
            }
        }

        /// <summary>
        /// Accessor to ATC (obtained by GET DATA) in <see cref="TLVData"/> format.
        /// </summary>
        public TLVData TlvATC
        {
            get { return _tlvATC; }
        }

        /// <summary>
        /// Accessor to Last Online ATC Register (obtained by GET DATA) in <see cref="TLVData"/> format.
        /// </summary>
        public TLVData TlvLastOnlineATCRegister
        {
            get { return _tlvLastOnlineATCRegister; }
            set { _tlvLastOnlineATCRegister = value; }
        }

        /// <summary>
        /// Accessor to PIN Try Counter (obtained by GET DATA) in <see cref="TLVData"/> format.
        /// </summary>
        public TLVData TlvPINTryCounter
        {
            get { return _tlvPINTryCounter; }
            set { _tlvPINTryCounter = value; }
        }

        /// <summary>
        /// Accessor to Log Format (obtained by GET DATA) in <see cref="TLVData"/> format.
        /// </summary>
        public TLVData TlvLogFormat
        {
            get { return _tlvLogFormat; }
            set { _tlvLogFormat = value; }
        }

        /// <summary>
        /// Accessor to DDOL.
        /// </summary>
        public DataObjectList Ddol
        {
            get
            {
                if (_ddol == null && TlvDataRecords.hasTag(0x9F49))
                    _ddol = new DataObjectList(TlvDataRecords.getTag(0x9F49).value);
                return _ddol;
            }
        }

        /// <summary>
        /// Accessor to CDOL1.
        /// </summary>
        public DataObjectList Cdol1
        {
            get
            {
                if (_cdol1 == null && TlvDataRecords.hasTag(0x8C))
                    _cdol1 = new DataObjectList(TlvDataRecords.getTag(0x8C).value);
                return _cdol1;
            }
        }

        /// <summary>
        /// Accessor to CDOL2.
        /// </summary>
        public DataObjectList Cdol2
        {
            get
            {
                if (_cdol2 == null && TlvDataRecords.hasTag(0x8D))
                    _cdol2 = new DataObjectList(TlvDataRecords.getTag(0x8D).value);
                return _cdol2;
            }
        }

        /// <summary>
        /// Accessor to the Certification Authority Public Key.
        /// </summary>
        public PublicKey CertificationAuthorityPublicKey
        {
            get
            {
                if (_certificationAuthorityPublicKey == null && TlvDataRecords.hasTag(0x8F))
                {
                    var caPublicKeyIndex = new CertificationAuthorityPublicKeyIndex(TlvDataRecords.getTag(0x8F));
                    var aidObject = new ApplicationIdentifier(Aid);
                    try
                    {
                        _certificationAuthorityPublicKey = CertificationAuthorityRepository.get(aidObject.StrRid, caPublicKeyIndex.tlv.value.toHexa());
                    }
                    catch (EMVCertificationAuthorityNotFoundException)
                    {
                        // TODO: something when CA is not found
                    }
                }
                return _certificationAuthorityPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key Certificate.
        /// </summary>
        public IssuerPublicKeyCertificate IssuerPublicKeyCertificate
        {
            get
            {
                if (_issuerPublicKeyCertificate == null && CertificationAuthorityPublicKey != null && TlvDataRecords.hasTag(0x90))
                {
                    _issuerPublicKeyCertificate = new IssuerPublicKeyCertificate();
                    _issuerPublicKeyCertificate.recoverFromSignature(TlvDataRecords.getTag(0x90).value, CertificationAuthorityPublicKey);
                }
                return _issuerPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the Issuer Public Key (recovered from Issuer Public Key Certificate).
        /// </summary>
        public PublicKey IssuerPublicKey
        {
            get
            {
                if (_issuerPublicKey == null && IssuerPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    var modulus = IssuerPublicKeyCertificate.publicKeyorLeftmostDigitsofthePublicKey.toHexa();
                    if (TlvDataRecords.hasTag(0x92))
                        modulus += TlvDataRecords.getTag(0x92).value.toHexa();
                    // Exponent from the ICC records
                    var exponent = TlvDataRecords.getTag(0x9F32).value.toHexa();
                    // Compute the public key
                    _issuerPublicKey = new PublicKey(modulus, exponent);
                }
                return _issuerPublicKey;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key Certificate.
        /// </summary>
        public IccPublicKeyCertificate IccPublicKeyCertificate
        {
            get
            {
                if (_iccPublicKeyCertificate == null && IssuerPublicKey != null && TlvDataRecords.hasTag(0x9F46))
                {
                    _iccPublicKeyCertificate = new IccPublicKeyCertificate();
                    _iccPublicKeyCertificate.recoverFromSignature(TlvDataRecords.getTag(0x9F46).value, IssuerPublicKey);
                }
                return _iccPublicKeyCertificate;
            }
        }

        /// <summary>
        /// Accessor to the ICC Public Key (recovered from ICC Public Key Certificate).
        /// </summary>
        public PublicKey IccPublicKey
        {
            get
            {
                if (_iccPublicKey == null && IccPublicKeyCertificate != null)
                {
                    // Public key modulus = modulus part contained in certificate + remainder from the ICC records
                    var modulus = IccPublicKeyCertificate.publicKeyorLeftmostDigitsofthePublicKey.toHexa();
                    if (TlvDataRecords.hasTag(0x9F48))
                        modulus += TlvDataRecords.getTag(0x9F48).value.toHexa();
                    // Exponent from the ICC records
                    var exponent = TlvDataRecords.getTag(0x9F47).value.toHexa();
                    // Compute the public key
                    _iccPublicKey = new PublicKey(modulus, exponent);
                }
                return _iccPublicKey;
            }
        }

        /// <summary>
        /// Accessor to SDA data.
        /// </summary>
        public StaticDataAuthentication Sda
        {
            get
            {
                if (_sda == null && TlvDataRecords.hasTag(0x93) && IssuerPublicKeyCertificate != null)
                {
                    _sda = new StaticDataAuthentication();
                    _sda.recoverFromSignature(TlvDataRecords.getTag(0x93).value, IssuerPublicKey);
                }
                return _sda;
            }
        }

        /// <summary>
        /// Accessor to DDA data.
        /// </summary>
        public virtual DynamicDataAuthentication Dda
        {
            get
            {
                if (_dda == null && TlvSignedDynamicApplicationResponse != null && IccPublicKeyCertificate != null)
                {
                    if (TlvDataRecords.hasTag(0x8F))
                    {
                        Byte[] signature = null;
                        if (TlvSignedDynamicApplicationResponse.tag == 0x80)
                        {
                            // Format 1
                            signature = TlvSignedDynamicApplicationResponse.value;
                        }
                        else if (TlvSignedDynamicApplicationResponse.tag == 0x77)
                        {
                            // Format 2
                            signature = TlvSignedDynamicApplicationResponse.getTag(0x9F4B).value;
                        }
                        _dda = new DynamicDataAuthentication();
                        _dda.recoverFromSignature(signature, IccPublicKey);
                    }
                }
                return _dda;
            }
        }

        /// <summary>
        /// Accessor to CDA data.
        /// </summary>
        public CombinedDataAuthentication Cda
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for INTERNAL AUTHENTICATE (DDA).
        /// </summary>
        public TLVData TlvInternalAuthenticateUnpredictableNumber
        {
            get { return _tlvInternalAuthenticateUnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the Signed Dynamic Application rAPDU obtained by INTERNAL AUTHENTICATE.
        /// </summary>
        /// <remarks>
        /// From EMV book 3:
        /// <para>Format 1: The data object returned in the rAPDU message is a primitive data object with tag equal to '80'.
        /// The value field consists of the value field of the Signed Dynamic Application Data as specified in Book 2</para>
        /// <para>Format 2: The data object returned in the rAPDU message is a constructed data object with tag equal to '77'.
        /// The value field may contain several BER-TLV coded objects, but shall always include the Signed Dynamic Application Data as specified in Book 2.</para>
        /// </remarks>
        public TLVData TlvSignedDynamicApplicationResponse
        {
            get { return _tlvSignedDynamicApplicationResponse; }
        }

        /// <summary>
        /// Accessor to the unpredictable number used for GENERATE AC 1.
        /// </summary>
        public TLVData TlvGenerateAC1UnpredictableNumber
        {
            get { return _tlvGenerateAC1UnpredictableNumber; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC1.
        /// </summary>
        public TLVData TlvGenerateAC1Response
        {
            get { return _tlvGenerateAC1Response; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by GENERATE AC2.
        /// </summary>
        public TLVData TlvGenerateAC2Response
        {
            get { return _tlvGenerateAC2Response; }
        }

        /// <summary>
        /// Accessor to last GET CHALLENGE rAPDU.
        /// </summary>
        public Byte[] IccChallenge
        {
            get { return _iccChallenge; }
        }

        /// <summary>
        /// Accessor to the rAPDU obtained by VERIFY PIN.
        /// </summary>
        public UInt16 VerifyPinStatusWord
        {
            get { return _verifyPinStatusWord; }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 1.
        /// </summary>
        public CryptogramType RequestedAC1Type
        {
            get { return _requestedAC1Type; }
        }

        /// <summary>
        /// Accessor to the CID obtained by GENERATE AC 1.
        /// </summary>
        public CryptogramInformationData Cid1
        {
            get
            {
                if (_cid1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        var rawCid = new Byte[1];
                        Array.Copy(_tlvGenerateAC1Response.value, 0, rawCid, 0, rawCid.Length);
                        _cid1 = new CryptogramInformationData(new TLVData(0x9F27, 1, rawCid));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _cid1 = new CryptogramInformationData(_tlvGenerateAC1Response.getTag(0x9F27));
                    }
                }
                return _cid1;
            }
        }

        /// <summary>
        /// Accessor to the ATC obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationTransactionCounter AtcFromAC1
        {
            get
            {
                if (_atcFromAC1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        var rawATC = new Byte[2];
                        Array.Copy(_tlvGenerateAC1Response.value, 1, rawATC, 0, rawATC.Length);
                        _atcFromAC1 = new ApplicationTransactionCounter(new TLVData(0x9F36, 2, rawATC));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _atcFromAC1 = new ApplicationTransactionCounter(_tlvGenerateAC1Response.getTag(0x9F36));
                    }
                }
                return _atcFromAC1;
            }
        }

        /// <summary>
        /// Accessor to the Application Cryptogram obtained by GENERATE AC 1.
        /// </summary>
        public ApplicationCryptogram ApplicationCryptogram
        {
            get
            {
                if (_applicationCryptogram1 == null && _tlvGenerateAC1Response != null)
                {
                    if (_tlvGenerateAC1Response.tag == 0x80)
                    {
                        // Format 1
                        var rawAC = new Byte[8];
                        Array.Copy(_tlvGenerateAC1Response.value, 0, rawAC, 0, rawAC.Length);
                        _applicationCryptogram1 = new ApplicationCryptogram(new TLVData(0x00, 8, rawAC));
                    }
                    else if (_tlvGenerateAC1Response.tag == 0x77)
                    {
                        _applicationCryptogram1 = new ApplicationCryptogram(_tlvGenerateAC1Response.getTag(0x9F4B));
                    }
                }
                return _applicationCryptogram1;
            }
        }

        /// <summary>
        /// Accessor to the Cryptogram Type used for GENERATE AC 2.
        /// </summary>
        public CryptogramType RequestedAC2Type
        {
            get { return _requestedAC2Type; }
        }

        #endregion

        #region >> Delegates

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.GetData"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeGetDataEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.GetData"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterGetDataEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.GetProcessingOptions"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeGetProcessingOptionsEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.GetProcessingOptions"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterGetProcessingOptionsEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.ReadApplicationData"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeReadApplicationDataEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.ReadApplicationData"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterReadApplicationDataEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.ReadLogFile"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeReadLogFileEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.ReadLogFile"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterReadLogFileEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.VerifyPin"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeVerifyPinEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.VerifyPin"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterVerifyPinEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.InternalAuthenticate"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeInternalAuthenticateEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.InternalAuthenticate"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterInternalAuthenticateEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.GetChallenge"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeGetChallengeEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.GetChallenge"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterGetChallengeEventHandler(EMVApplication emv);

        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.GenerateAc1"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeGenerateAC1EventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="EMVApplication.GenerateAc1"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterGenerateAC1EventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent before execution of <see cref="EMVApplication.ComputeCryptographicChecksum"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void BeforeComputeCryptographicChecksumEventHandler(EMVApplication emv);
        /// <summary>
        /// Delegate for event sent after execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        /// <param name="emv">Caller instance.</param>
        public delegate void AfterComputeCryptographicChecksumEventHandler(EMVApplication emv);

        #endregion

        #region >> Events

        /// <summary>
        /// Event sent before execution of <see cref="GetData"/>.
        /// </summary>
        public event BeforeGetDataEventHandler BeforeGetDataEvent;
        /// <summary>
        /// Event sent after execution of <see cref="GetData"/>.
        /// </summary>
        public event AfterGetDataEventHandler AfterGetDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event BeforeGetProcessingOptionsEventHandler BeforeGetProcessingOptionsEvent;
        /// <summary>
        /// Event sent after execution of <see cref="GetProcessingOptions"/>.
        /// </summary>
        public event AfterGetProcessingOptionsEventHandler AfterGetProcessingOptionsEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event BeforeReadApplicationDataEventHandler BeforeReadApplicationDataEvent;
        /// <summary>
        /// Event sent after execution of <see cref="ReadApplicationData"/>.
        /// </summary>
        public event AfterReadApplicationDataEventHandler AfterReadApplicationDataEvent;

        /// <summary>
        /// Event sent before execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event BeforeGetDataEventHandler BeforeReadLogFileEvent;
        /// <summary>
        /// Event sent after execution of <see cref="ReadLogFile"/>.
        /// </summary>
        public event AfterGetDataEventHandler AfterReadLogFileEvent;

        /// <summary>
        /// Event sent before execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event BeforeVerifyPinEventHandler BeforeVerifyPinEvent;
        /// <summary>
        /// Event sent after execution of <see cref="VerifyPin"/>.
        /// </summary>
        public event AfterVerifyPinEventHandler AfterVerifyPinEvent;

        /// <summary>
        /// Event sent before execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event BeforeInternalAuthenticateEventHandler BeforeInternalAuthenticateEvent;
        /// <summary>
        /// Event sent after execution of <see cref="InternalAuthenticate"/>.
        /// </summary>
        public event AfterInternalAuthenticateEventHandler AfterInternalAuthenticateEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event BeforeGetChallengeEventHandler BeforeGetChallengeEvent;
        /// <summary>
        /// Event sent after execution of <see cref="GetChallenge"/>.
        /// </summary>
        public event AfterGetChallengeEventHandler AfterGetChallengeEvent;

        /// <summary>
        /// Event sent before execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event BeforeGenerateAC1EventHandler BeforeGenerateAC1Event;
        /// <summary>
        /// Event sent after execution of <see cref="GenerateAc1"/>.
        /// </summary>
        public event AfterGenerateAC1EventHandler AfterGenerateAC1Event;

        /// <summary>
        /// Event sent before execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event BeforeComputeCryptographicChecksumEventHandler BeforeComputeCryptographicChecksumEvent;
        /// <summary>
        /// Event sent after execution of <see cref="ComputeCryptographicChecksum()"/>.
        /// </summary>
        public event AfterComputeCryptographicChecksumEventHandler AfterComputeCryptographicChecksumEvent;

        #endregion

        #region >> Constructors

        /// <summary>
        /// Initializes a new <see cref="EMVApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        public EMVApplication(ICardChannel cardChannel)
            : base(cardChannel)
        {
            _tlvRecords = new List<TLVData>();
            _tlvOfflineRecords = new List<TLVData>();
        }

        /// <summary>
        /// Initializes a new <see cref="EMVApplication"/> instance.
        /// </summary>
        /// <param name="cardChannel"><see cref="ICardChannel">ICardChannel</see> object to use</param>
        /// <param name="tlvFromPSE"><see cref="TLVData">TLVData</see> object coming from PSE records for this application</param>
        public EMVApplication(ICardChannel cardChannel, TLVData tlvFromPSE)
            : this(cardChannel)
        {
            _tlvFromPSE = tlvFromPSE;
            if (_tlvFromPSE.hasTag(0x4F))
            {
                Aid = _tlvFromPSE.getTag(0x4F).value.toHexa();
            }
        }

        #endregion

        #region >> Methods

        /// <summary>
        /// Process the GET PROCESSING OPTIONS phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetProcessingOptions()
        {
            if (BeforeGetProcessingOptionsEvent != null) BeforeGetProcessingOptionsEvent(this);

            // If PDOL 9F38 is not supplied in FCI, then used 8300 as UDC; if supplied: build the PDOL in tag 83 L V
            Byte[] pdolDataValue;
            if (TlvFci.hasTag(0x9F38))
            {
                // Use PDOL to build tag 83 value
                var pdol = new DataObjectList(TlvFci.getTag(0x9F38).value);
                var tlvAll = new List<TLVData>();
                tlvAll.Add(TlvFci);
                tlvAll.AddRange(TlvTerminalData);
                pdolDataValue = pdol.BuildData(tlvAll);
            }
            else
            {
                pdolDataValue = new Byte[0];
            }
            // Build tag 83 with computed value
            var tlvPdolData = new TLVData(0x83, (uint)pdolDataValue.Length, pdolDataValue);

            // Execute GET PROCESSING OPTIONS
            var cAPDU = new CommandAPDU(0x80, 0xA8, 0x00, 0x00, tlvPdolData.length + 2, tlvPdolData.toByteArray(), 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);

            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvProcessingOptions = new TLVData();

                crp = new CommandResponsePair(new GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvProcessingOptions = new TLVData(crp.rAPDU.udr);
            }

            if (AfterGetProcessingOptionsEvent != null) AfterGetProcessingOptionsEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads the file pointed by the SFI found in the FCI of the application.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadDataFile(ApplicationFileLocator.FileIdentification file)
        {
            for (var recordNumber = file.FirstRecord; recordNumber <= file.LastRecord; recordNumber++)
            {
                CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, file.Sfi, 0);
                var crp = new CommandResponsePair(cAPDU);
                crp.transmit(_cardChannel);

                if (crp.rAPDU.statusWord == 0x9000)
                {
                    var tlv = new TLVData(crp.rAPDU.udr);
                    // Store data in list
                    _tlvRecords.Add(tlv);

                    if (tlv.tag != 0x70)
                        throw new Exception(String.Format("EMVApplication.readData(): record is not TLV-coded with tag 70 [{0}]", tlv));

                    // If used for offline, store it in dedicated list
                    if (recordNumber - file.FirstRecord < file.OfflineNumberOfRecords)
                    {
                        // For files with SFI in the range 1 to 10, the record tag ('70') and the record length are excluded from the offline data authentication process.
                        if (file.Sfi <= 10)
                        {
                            foreach (var tlvData in tlv.subFields)
                                _tlvOfflineRecords.Add(tlvData);
                        }
                        //For files with SFI in the range 11 to 30, the record tag ('70') and the record length are not excluded from the offline data authentication process.
                        else
                        {
                            _tlvOfflineRecords.Add(tlv);
                        }
                    }
                }
                _lastStatusWord = crp.rAPDU.statusWord;
            }
            return _lastStatusWord;
        }

        /// <summary>
        /// Process the READ APPLICATION DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadApplicationData()
        {
            if (BeforeReadApplicationDataEvent != null) BeforeReadApplicationDataEvent(this);

            foreach (ApplicationFileLocator.FileIdentification file in Afl.GetFiles())
            {
                ReadDataFile(file);
            }

            if (AfterReadApplicationDataEvent != null) AfterReadApplicationDataEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET DATA phase of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetData()
        {
            if (BeforeGetDataEvent != null) BeforeGetDataEvent(this);

            GetData(0x9F36, ref _tlvATC);
            GetData(0x9F13, ref _tlvLastOnlineATCRegister);
            GetData(0x9F17, ref _tlvPINTryCounter);
            GetData(0x9F4F, ref _tlvLogFormat);

            if (AfterGetDataEvent != null) AfterGetDataEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process a GET DATA to retrieve one EMV information.
        /// </summary>
        /// <param name="tag">
        ///     <list type="bullet">
        ///         <item><c>0x9F36</c> for ATC</item>
        ///         <item><c>0x9F13</c> for Last Online ATC Register</item>
        ///         <item><c>0x9F17</c> for PIN Try Counter</item>
        ///         <item><c>0x9F4F</c> for Log Format</item>
        ///     </list>
        /// </param>
        /// <param name="tlv"></param>
        /// <returns>Last status word.</returns>
        protected UInt16 GetData(UInt32 tag, ref TLVData tlv)
        {
            // Execute GET DATA instruction
            var cAPDU = new CommandAPDU(0x80, 0xCA, (Byte)(tag / 0x100), (Byte)(tag % 0x100), 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // Finally store rAPDU
            if (crp.rAPDU.statusWord == 0x9000)
            {
                tlv = new TLVData(crp.rAPDU.udr);
            }

            return _lastStatusWord;
        }

        /// <summary>
        /// Reads log file of the EMV application. Records are stored.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ReadLogFile()
        {
            if (BeforeReadLogFileEvent != null) BeforeReadLogFileEvent(this);

            if (LogEntry == null)
                throw new LogEntryNotFoundException(String.Format("EMVApplication.readLogFile(): logEntry ({0}) undefined.", _logEntry));

            if (LogFormat == null)
                throw new LogFormatNotFoundException(String.Format("EMVApplication.readLogFile(): logFormat ({0}) undefined.", _logFormat));

            _logRecords = new List<List<TLVData>>();

            Byte recordNumber = 0;
            do
            {
                recordNumber++;
                CommandAPDU cAPDU = new EMVReadRecordCommand(recordNumber, LogEntry.Sfi, 0);
                var crp = new CommandResponsePair(cAPDU);
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
                if (crp.rAPDU.statusWord == 0x9000)
                {
                    var record = crp.rAPDU.udr;
                    var dataInRecord = _logFormat.ParseRawData(record);
                    _logRecords.Add(dataInRecord);
                }

            } while (_lastStatusWord == 0x9000 && recordNumber < _logEntry.CyclicFileSize);

            if (AfterReadLogFileEvent != null) AfterReadLogFileEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the VERIFY PIN phase of an EMV transaction.
        /// </summary>
        /// <param name="pinBlock">PIN Block.</param>
        /// <returns>Last status word.</returns>
        public UInt16 VerifyPin(PINBlock pinBlock)
        {
            if (BeforeVerifyPinEvent != null) BeforeVerifyPinEvent(this);

            Byte p2 = 0x00;
            if (pinBlock is PlaintextPINBlock)
                p2 = 0x80;

            // Execute the VERIFY instruction
            var cAPDU = new CommandAPDU(0x00, 0x20, 0x00, p2, (UInt32)pinBlock.PinBlock.Length, pinBlock.PinBlock);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;
            _verifyPinStatusWord = _lastStatusWord;

            if (_lastStatusWord != 0x9000)
                Tvr.CardholderVerificationFailed = true;

            if (AfterVerifyPinEvent != null) AfterVerifyPinEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the INTERNAL AUTHENTICATION of an EMV transaction.
        /// </summary>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 InternalAuthenticate(Byte[] unpredictableNumber)
        {
            _tlvInternalAuthenticateUnpredictableNumber = new TLVData(0x9F37, 0x04, unpredictableNumber);

            if (BeforeInternalAuthenticateEvent != null) BeforeInternalAuthenticateEvent(this);

            // Build DDOL data
            Byte[] ddolDataValue;
            if (Ddol != null)
            {
                // Use DDOL to build data
                var tlvAll = new List<TLVData>();
                tlvAll.Add(TlvFci);
                tlvAll.Add(TlvProcessingOptions);
                tlvAll.Add(_tlvInternalAuthenticateUnpredictableNumber);
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                ddolDataValue = Ddol.BuildData(tlvAll);
            }
            else
            {
                ddolDataValue = new Byte[0];
            }

            // Execute GET PROCESSING OPTIONS
            var cAPDU = new CommandAPDU(0x00, 0x88, 0x00, 0x00, (uint)ddolDataValue.Length, ddolDataValue, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvSignedDynamicApplicationResponse = new TLVData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvSignedDynamicApplicationResponse = new TLVData(crp.rAPDU.udr);
            }

            if (AfterInternalAuthenticateEvent != null) AfterInternalAuthenticateEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GET CHALLENGE of an EMV transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 GetChallenge()
        {
            if (BeforeGetChallengeEvent != null) BeforeGetChallengeEvent(this);

            // Clear previous challenge
            _iccChallenge = null;

            // Execute GET CHALLENGE
            var cAPDU = new CommandAPDU(0x00, 0x84, 0x00, 0x00, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                crp = new CommandResponsePair(new GetResponseCommand(crp.rAPDU.sw2));
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _iccChallenge = crp.rAPDU.udr;
            }

            if (AfterGetChallengeEvent != null) AfterGetChallengeEvent(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// Process the GENERATE APPLICATION CRYPTOGRAM 1 of an EMV transaction.
        /// </summary>
        /// <param name="cryptogramType">Type of the cryptogram to be generated.</param>
        /// <param name="unpredictableNumber">Unpredictable number.</param>
        /// <returns>Last status word.</returns>
        public UInt16 GenerateAc1(CryptogramType cryptogramType, Byte[] unpredictableNumber)
        {
            _tlvGenerateAC1UnpredictableNumber = new TLVData(0x9F37, (uint)unpredictableNumber.Length, unpredictableNumber);

            _requestedAC1Type = cryptogramType;

            if (BeforeGenerateAC1Event != null) BeforeGenerateAC1Event(this);

            Byte referenceControlParameter;
            switch (cryptogramType)
            {
                case CryptogramType.AAC:
                    referenceControlParameter = 0x00;
                    break;
                case CryptogramType.ARQC:
                    referenceControlParameter = 0x80;
                    break;
                case CryptogramType.TC:
                    referenceControlParameter = 0x40;
                    break;
                default:
                    throw new Exception(String.Format("EMVApplication.generateAC1: bad Cryptogram Type [{0}]", cryptogramType));
            }

            // TODO: if CDA signature requested, set bit 5 to 1 (0x08)

            // Build CDOL1 data
            Byte[] cdolDataValue;
            if (Cdol1 != null)
            {
                // Use CDOL1 to build data
                var tlvAll = new List<TLVData>();
                tlvAll.Add(TlvFci);
                tlvAll.Add(TlvProcessingOptions);
                tlvAll.Add(_tlvGenerateAC1UnpredictableNumber);
                tlvAll.AddRange(TlvRecords);
                tlvAll.AddRange(TlvTerminalData);
                tlvAll.Add(Tvr.tlv);
                cdolDataValue = Cdol1.BuildData(tlvAll);
            }
            else
            {
                cdolDataValue = new Byte[0];
            }

            // Execute GENERATE AC
            var cAPDU = new CommandAPDU(0x80, 0xAE, referenceControlParameter, 0x00, (UInt32)cdolDataValue.Length, cdolDataValue, 0); // Bad APDU !
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);

            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvGenerateAC1Response = new TLVData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvGenerateAC1Response = new TLVData(crp.rAPDU.udr);
            }

            if (AfterGenerateAC1Event != null) AfterGenerateAC1Event(this);

            return _lastStatusWord;
        }

        /// <summary>
        /// MasterCard cAPDU.
        /// Process the COMPUTE CRYPTOGRAPHIC CHECKSUM phase of a MasterCard transaction.
        /// </summary>
        /// <returns>Last status word.</returns>
        public UInt16 ComputeCryptographicChecksum()
        {
            if (BeforeComputeCryptographicChecksumEvent != null) BeforeComputeCryptographicChecksumEvent(this);

            // If UDOL 9F69 is not supplied in records, then use default UDOL = 9F6A04
            Byte[] udolDataValue = null;
            var tlvAll = new List<TLVData>();
            foreach (var record in _tlvRecords)
            {
                tlvAll.Add(record);
                if (record.hasTag(0x9F69))
                {
                    var udol = new DataObjectList(record.getTag(0x9F69).value);
                    tlvAll.AddRange(TlvTerminalData);
                    udolDataValue = udol.BuildData(tlvAll);
                }
            }

            if (udolDataValue == null)
            {
                var tmp = "";
                var seed = new Random(10000).Next();
                var rndNumbers = new Random(seed);
                for (var i = 0; i < 8; i++)
                {
                    var rndNumber = rndNumbers.Next(10);
                    tmp += rndNumber.ToString(CultureInfo.InvariantCulture);
                }
                udolDataValue = tmp.fromHexa();
            }

            // Execute COMPUTE CRYPTOGRAPHIC CHECKSUM
            var cAPDU = new CommandAPDU(0x80, 0x2A, 0x8E, 0x80, (uint)udolDataValue.Length, udolDataValue, 0);
            var crp = new CommandResponsePair(cAPDU);
            crp.transmit(_cardChannel);
            _lastStatusWord = crp.rAPDU.statusWord;

            // If GET RESPONSE needed, do it
            if (crp.rAPDU.sw1 == 0x61)
            {
                _tlvCryptographicChecksum = new TLVData();
                crp = new CommandResponsePair(new GetResponseCommand(crp.rAPDU.sw2));
                crp.transmit(_cardChannel);
                _lastStatusWord = crp.rAPDU.statusWord;
            }

            // Finally, store result
            if (crp.rAPDU.statusWord == 0x9000)
            {
                _tlvCryptographicChecksum = new TLVData(crp.rAPDU.udr);
            }

            if (AfterComputeCryptographicChecksumEvent != null) AfterComputeCryptographicChecksumEvent(this);

            return _lastStatusWord;

        }

        #endregion
    }
}
