using System;
using WSCT.Helpers.BasicEncodingRules;

namespace WSCT.EMV.Objects
{
    /// <summary>
    /// Represents the Cryptogram Information Data of a cryptogram generated by an EMV card.
    /// </summary>
    public class CryptogramInformationData : BinaryTlvObject
    {
        #region >> Internal constants

        private const byte AdviceRequiredBit = 0x08;

        #region >> Properties

        /// <summary>
        /// Reasons.
        /// </summary>
        public enum Reason
        {
            /// <summary>
            /// No information given.
            /// </summary>
            ReasonNoinformationgiven = 0x00,

            /// <summary>
            /// Service not allowed.
            /// </summary>
            ReasonServicenotallowed = 0x01,

            /// <summary>
            /// Pin try counter limit exceeded.
            /// </summary>
            ReasonPinTryLimitExceeded = 0x02,

            /// <summary>
            /// Issuer authentication failed.
            /// </summary>
            ReasonIssuerAuthenticationfailed = 0x03
        }

        #endregion

        /// <summary>
        /// CID: Cryptogram Type.
        /// </summary>
        public CryptogramType CryptogramType
        {
            get { return (CryptogramType)(Tlv.Value[0] & 0xC0); }
        }

        /// <summary>
        /// CID: Advice Required.
        /// </summary>
        public Boolean AdviceRequired
        {
            get { return Test(0, AdviceRequiredBit); }
            set { Force(0, AdviceRequiredBit, value); }
        }

        /// <summary>
        /// CID: reason / advice code.
        /// </summary>
        public byte ReasonCode
        {
            get { return (byte)(Tlv.Value[0] & 0x07); }
        }

        /// <summary>
        /// CID: Reason - no information given.
        /// </summary>
        public Boolean ReasonNoInformationGiven
        {
            get { return (ReasonCode & (int)Reason.ReasonNoinformationgiven) == (int)Reason.ReasonNoinformationgiven; }
        }

        /// <summary>
        /// CID: Reason - service not allowed.
        /// </summary>
        public Boolean ReasonServiceNotAllowed
        {
            get { return (ReasonCode & (int)Reason.ReasonServicenotallowed) == (int)Reason.ReasonServicenotallowed; }
        }

        /// <summary>
        /// CID: Reason - PIN try limit exceeded.
        /// </summary>
        public Boolean ReasonPINTryLimitExceeded
        {
            get { return (ReasonCode & (int)Reason.ReasonPinTryLimitExceeded) == (int)Reason.ReasonPinTryLimitExceeded; }
        }

        /// <summary>
        /// CID: Reason - IssuerAuthenticationFailed.
        /// </summary>
        public Boolean ReasonIssuerAuthenticationFailed
        {
            get { return (ReasonCode & (int)Reason.ReasonIssuerAuthenticationfailed) == (int)Reason.ReasonIssuerAuthenticationfailed; }
        }

        #endregion

        #region >> Constructors

        /// <summary>
        /// Initializes a new <see cref="CryptogramInformationData"/> instance.
        /// </summary>
        public CryptogramInformationData()
        {
            Tlv = new TlvData();
        }

        /// <summary>
        /// Initializes a new <see cref="CryptogramInformationData"/> instance.
        /// </summary>
        /// <param name="tlvCid">TLV CID data.</param>
        public CryptogramInformationData(TlvData tlvCid)
            : this()
        {
            Tlv = tlvCid;
        }

        #endregion

        #region >> Methods

        private Boolean Test(byte byteNumber, byte bit)
        {
            if (Tlv.Value.Length == 0)
            {
                Tlv.Value = new byte[5];
            }

            return (Tlv.Value[byteNumber] & bit) == bit;
        }

        private void Force(byte byteNumber, byte bit, Boolean value)
        {
            if (Tlv.Value.Length == 0)
            {
                Tlv.Value = new byte[5];
            }
            if (value)
            {
                Tlv.Value[byteNumber] |= bit;
            }
            else
            {
                Tlv.Value[byteNumber] &= (byte)(~bit);
            }
        }

        /// <inheritdoc />
        public override string ToString()
        {
            var s = "";
            s += String.Format("{0}", CryptogramType);
            if (ReasonNoInformationGiven)
            {
                s += " (no information given)";
            }
            else if (ReasonServiceNotAllowed)
            {
                s += " (service not allowed)";
            }
            else if (ReasonPINTryLimitExceeded)
            {
                s += " (PIN try limit exceeded)";
            }
            else if (ReasonIssuerAuthenticationFailed)
            {
                s += " (issuer authentication failed)";
            }
            else
            {
                s += String.Format(" (reason:{0})", ReasonCode);
            }
            return s;
        }

        #endregion
    }
}